# 上級コラム: Webレンダリング深層理解

## Chapter 1: ブラウザの気持ちになって考える

### Section 2: リフローとリペイント、そしてコンポジット

🎯 **このセクションで学ぶこと**

-   Webページのインタラクションによって引き起こされるレンダリングの更新処理、「リフロー」と「リペイント」の違いを明確に理解する。
-   どのようなDOM/CSSの変更がリフローを引き起こし、どのような変更がリペイントのみで済むのかを区別できるようになる。
-   リフローもリペイントも引き起こさない、最も効率的な「コンポジット」処理について理解し、`transform`と`opacity`がなぜアニメーションに有利なのかを説明できるようになる。

--- 

### イントロダクション：変化に適応するブラウザ

Webページは静的なものではありません。ユーザーのマウス操作、スクロール、入力、あるいはJavaScriptによる動的なコンテンツの更新など、常に変化にさらされています。

ブラウザは、これらの変化に対応するために、クリティカルレンダリングパスの一部を再実行する必要があります。しかし、すべての変更が同じコストを要求するわけではありません。変更の種類によって、ブラウザが行う作業の範囲は大きく異なります。この更新プロセスは、主に**リフロー（Reflow）**、**リペイント（Repaint）**、そして**コンポジット（Composite）**の3つのレベルに分けられます。

これらの違いを理解することは、スムーズなアニメーションや高速なUI応答性を実現するための鍵となります。

--- 

### 🌊 3段階の更新プロセス

#### 1. リフロー (Reflow)

-   **トリガー**: 要素の**幾何学的な情報**（サイズ、位置、形状）に影響を与える変更。
-   **処理内容**: 
    1.  影響を受けた要素、およびそのすべての子孫要素、さらには後続の要素の**レイアウトを再計算**する。
    2.  再計算されたレイアウト情報に基づいて、影響範囲の**ピクセルを再描画（リペイント）**する。
-   **コスト**: **最も高価**。レイアウトの再計算はCPU負荷が高く、影響範囲がページ全体に及ぶ（Global Reflow）こともあります。

**リフローを引き起こす主なプロパティ/操作:**

-   要素の追加、削除、内容の変更
-   `width`, `height`, `margin`, `padding`, `border`の変更
-   `top`, `left`, `right`, `bottom`の変更
-   フォントサイズやフォントファミリーの変更
-   ウィンドウのリサイズ
-   `offsetTop`, `offsetLeft`, `clientWidth`などの特定のプロパティの**読み取り**（ブラウザは正確な値を返すために、保留中のレイアウト変更を強制的に実行する必要があるため。これを「強制同調レイアウト」と呼びます）

リフローは、ドミノ倒しのように連鎖的な更新を引き起こす可能性があるため、特にアニメーションのような頻繁な更新では、可能な限り避けるべきです。 

#### 2. リペイント (Repaint)

-   **トリガー**: 要素の**見た目**（色、背景、影など）には影響するが、**幾何学的な情報には影響しない**変更。
-   **処理内容**: 
    1.  レイアウトの計算はスキップする。
    2.  要素の**ピクセルを再描画**するだけ。
-   **コスト**: **中程度**。リフローよりははるかに安価ですが、それでもGPU（またはCPU）に描画処理を要求します。

**リペイントのみを引き起こす主なプロパティ:**

-   `color`, `background-color`, `background-image`
-   `outline`, `visibility`
-   `box-shadow`, `text-decoration`

#### 3. コンポジット (Composite)

-   **トリガー**: レイヤーの位置や透明度のみを変更する特定のプロパティの変更。
-   **処理内容**: 
    1.  レイアウトとペイントの両方をスキップする。
    2.  GPU上で、すでに描画済みのレイヤーを**合成**するだけ。
-   **コスト**: **最も安価**。CPUをほとんど使わず、GPUの得意な処理だけで完結するため、非常に高速です。

**コンポジットのみを引き起こす主なプロパティ:**

-   `transform` (translate, rotate, scale)
-   `opacity`

これが、**アニメーションには`top`や`left`の代わりに`transform: translate()`を、表示/非表示の切り替えには`display`の代わりに`opacity`を使うことが強く推奨される**理由です。`transform`と`opacity`は、ブラウザが要素を独立したレイヤーとして扱うように促し（これをレイヤープロモーションと呼びます）、リフローやリペイントという高価な処理をバイパスして、GPUだけで高速にアニメーションを実行できるようにします。

--- 

### 比較表：どの変更がどの処理を引き起こすか

| 変更内容 | 例 | リフロー？ | リペイント？ | コスト |
|:---|:---|:---:|:---:|:---:|
| **ジオメトリ変更** | `width`, `height`, `margin`, `left` | ✅ | ✅ | **高** |
| **ビジュアル変更** | `color`, `background-color` | ❌ | ✅ | **中** |
| **コンポジット変更**| `transform`, `opacity` | ❌ | ❌ | **低** |

--- 

### 🛠️ パフォーマンス改善のためのヒント

-   **`transform`と`opacity`を愛用する**: アニメーションや要素の移動には、`position`プロパティ（`top`, `left`）ではなく、`transform`を使いましょう。
-   **レイアウトスラッシングを避ける**: JavaScriptで、DOMのスタイルを「書き込み」と「読み取り」を交互に繰り返すのは最悪のパターンです。これは「強制同調レイアウト」を何度も引き起こし、パフォーマンスを著しく低下させます。読み取りはまとめて最初に行い、書き込みはまとめて最後に行うようにしましょう。

    ```javascript
    // 悪い例：書き込みと読み取りの繰り返し
    function resizeAllParagraphs() {
      const paragraphs = document.querySelectorAll("p");
      for (let i = 0; i < paragraphs.length; i++) {
        // 書き込み
        paragraphs[i].style.width = document.body.clientWidth + "px";
      }
    }

    // 良い例：読み取りを先に行う
    function resizeAllParagraphs() {
      const paragraphs = document.querySelectorAll("p");
      const width = document.body.clientWidth; // 最初に一度だけ読み取る
      for (let i = 0; i < paragraphs.length; i++) {
        // 書き込み
        paragraphs[i].style.width = width + "px";
      }
    }
    ```

-   **`will-change`プロパティ**: これから変更が加わる予定のプロパティをブラウザに事前に伝えることで、ブラウザが最適化（例: 事前にレイヤーを生成しておく）を行う手助けをします。ただし、多用は禁物で、本当に必要な場合にのみ使用してください。

    ```css
    .animating-element {
      will-change: transform, opacity;
    }
    ```

--- 

✨ **まとめ**

-   DOMの変更に対するブラウザの更新処理には、コストの高い順に**リフロー**、**リペイント**、**コンポジット**の3段階がある。
-   **リフロー**は要素のジオメトリ（位置やサイズ）の変更によって発生し、レイアウトの再計算とリペイントの両方を引き起こす最も高価な処理である。
-   **リペイント**はジオメトリに影響しない見た目の変更によって発生し、レイアウトをスキップしてピクセルの再描画のみを行う。
-   **コンポジット**は`transform`と`opacity`の変更によって発生し、レイアウトもリペイントもスキップしてGPU上でレイヤーを合成するだけの最も安価な処理である。
-   スムーズなアニメーションを実現するには、リフローとリペイントを避け、コンポジット処理をトリガーするプロパティを積極的に利用することが鍵となる。

📝 **学習のポイント**

-   [ ] Chromeのデベロッパーツールで、ある要素の`margin`を変更したときと、`transform: translateX()`を変更したときで、「Performance」タブの記録にどのような違いが現れるか観察してみましょう。紫色の「Layout」イベントや緑色の「Paint」イベントの発生頻度に注目してください。
-   [ ] `visibility: hidden;`と`display: none;`は、どちらも要素を非表示にしますが、レンダリングパスに与える影響は異なります。その違いをリフローとリペイントの観点から説明してください。
-   [ ] なぜ`offsetTop`のようなプロパティを読み取るだけで、リフローが強制的に実行されてしまうのでしょうか？ ブラウザがもし保留中の変更を適用せずに値を返した場合、どのような問題が起こりうるか考えてみましょう。
