# Tutorial 5: JavaScript応用と非同期処理

## Chapter 1: 関数とスコープ

### Chapter 1 ハンズオン: TODOリスト管理関数を作成する

🎯 **このハンズオンで達成すること**

-   ここまでに学んだ関数の知識を総動員し、TODOリストを管理するための一連の関数を作成する。
-   アロー関数、引数、戻り値、デフォルト引数を実践的な文脈で使えるようになる。
-   スコープの概念を意識し、グローバルスコープを汚染しないように関数を設計できるようになる。

--- 

🖼️ **完成イメージ**

このハンズオンでは、コンソール上で動作するシンプルなTODOリスト管理機能を作成します。具体的には、以下の3つの関数を実装し、それらを組み合わせてTODOリストを操作します。

1.  `addTask(tasks, title, completed = false)`: 新しいタスクをリストに追加する関数。
2.  `displayTasks(tasks)`: 現在のタスク一覧を見やすく表示する関数。
3.  `findTaskByTitle(tasks, title)`: タイトルでタスクを検索する関数。

**最終的なコンソール出力のイメージ:**
```
--- TODOリスト ---
[ ] (ID: 1) JavaScriptの勉強
[ ] (ID: 2) 部屋の掃除
[x] (ID: 3) 牛乳を買う
------------------

「部屋の掃除」を検索中...
見つかりました: { id: 2, title: '部屋の掃除', completed: false }
```

--- 

### 🧠 先輩エンジニアの思考プロセス

「コンソールで動くTODOアプリの関数を作って」と頼まれたとき、頭の中ではまず「データ」と「操作」を分離して考えます。

| 手順 | 思考プロセス |
|:---|:---|
| **1. データ構造の決定** | まず、TODOリストのデータはどういう形にしようか。タスク一つひとつは、IDとタイトルと完了状態を持つオブジェクトがいいな。`{ id: 1, title: '...', completed: false }`。そして、TODOリスト全体は、そのオブジェクトの配列`[]`にしよう。 |
| **2. グローバル変数の定義** | このTODOリストの配列は、複数の関数から参照・変更されるから、グローバルスコープに置いておこう。`let tasks = [...]`。IDが重複しないように、次のIDを管理する変数`let nextId = 1`も必要だな。 |
| **3. 関数の役割分担** | 次に、どんな「操作」が必要か考える。「追加」「表示」「検索」...。よし、それぞれの操作を一つの関数に対応させよう。`addTask`, `displayTasks`, `findTaskByTitle`。 |
| **4. 関数のインターフェース設計** | 各関数が必要な情報（引数）と、返す結果（戻り値）を考える。`addTask`はタスクの配列とタイトルが必要。`displayTasks`はタスクの配列だけ。`findTaskByTitle`は配列と検索タイトルが必要で、見つかったタスクを返すべきだな。 |
| **5. 実装とテスト** | 設計に従って、一つずつ関数を実装していく。実装したら、すぐに呼び出して正しく動くかテストする。 |

💡 **ポイント:** **「データ（状態）」と「ロジック（操作）」を分けて考える**ことは、あらゆるプログラミングの基本です。関数は、まさに「ロジック」をカプセル化するための強力なツールです。

--- 

### 🏃 実践: Step by StepでTODO管理関数を作成しよう

`index.html`に`<script>`タグを用意し、その中にJavaScriptを記述していきます。（または、別の`.js`ファイルを作成して読み込んでも構いません）

#### Step 1: データ構造とグローバル変数の準備

まず、アプリケーションの核となるTODOリストのデータと、新しいタスクのIDを管理するための変数をグローバルスコープに定義します。

```javascript
// script.js

// タスクリストの初期データ
let tasks = [
  { id: 1, title: "JavaScriptの勉強", completed: false },
  { id: 2, title: "部屋の掃除", completed: false },
  { id: 3, title: "牛乳を買う", completed: true },
];

// 次に追加するタスクのID
let nextId = 4;
```

#### Step 2: `displayTasks` 関数の作成

現在のタスク一覧をコンソールに表示する関数を作成します。引数としてタスクの配列を受け取ります。

```javascript
// script.js (続き)

const displayTasks = (taskList) => {
  console.log("--- TODOリスト ---");
  for (const task of taskList) {
    const status = task.completed ? "[x]" : "[ ]";
    console.log(`${status} (ID: ${task.id}) ${task.title}`);
  }
  console.log("------------------");
};
```

-   **コードリーディング**
    -   `for...of`ループを使って、配列の各タスクを順番に処理します。
    -   三項演算子を使い、`completed`プロパティの値に応じて、ステータス表示を`[x]`と`[ ]`で切り替えています。

#### Step 3: `addTask` 関数の作成

新しいタスクをリストに追加する関数を作成します。引数として、操作対象のタスク配列、新しいタスクのタイトル、そしてオプションで完了状態を受け取ります。完了状態が渡されなかった場合は、デフォルトで`false`になるようにします。

```javascript
// script.js (続き)

const addTask = (taskList, title, completed = false) => {
  const newTask = {
    id: nextId,
    title: title,
    completed: completed,
  };

  taskList.push(newTask);
  nextId++; // 次のIDをインクリメント

  console.log(`タスク「${title}」を追加しました。`);
};
```

-   **コードリーディング**
    -   `completed = false`: デフォルト引数を設定しています。
    -   `taskList.push(newTask)`: 配列の末尾に新しい要素を追加するメソッドです。
    -   `nextId++`: 新しいタスクを追加したので、次のIDを1増やしておきます。

#### Step 4: 関数の呼び出しと動作確認

作成した関数を実際に呼び出して、TODOリストが正しく更新されるか確認しましょう。

```javascript
// script.js (続き)

// 最初の状態を表示
displayTasks(tasks);

// 新しいタスクを追加
addTask(tasks, "請求書の作成");

// 追加後の状態を再表示
displayTasks(tasks);
```

ブラウザのコンソールを開くと、以下のように表示されるはずです。

```
--- TODOリスト ---
[ ] (ID: 1) JavaScriptの勉強
[ ] (ID: 2) 部屋の掃除
[x] (ID: 3) 牛乳を買う
------------------
タスク「請求書の作成」を追加しました。
--- TODOリスト ---
[ ] (ID: 1) JavaScriptの勉強
[ ] (ID: 2) 部屋の掃除
[x] (ID: 3) 牛乳を買う
[ ] (ID: 4) 請求書の作成
------------------
```

#### Step 5: `findTaskByTitle` 関数の作成（応用）

最後に、タスクのタイトルを元に、配列から特定のタスクオブジェクトを見つけて返す関数を作成します。

```javascript
// script.js (続き)

const findTaskByTitle = (taskList, title) => {
  for (const task of taskList) {
    if (task.title === title) {
      return task; // 見つかったら、そのタスクオブジェクトを返して関数を終了
    }
  }
  return null; // ループが最後まで終わっても見つからなかったらnullを返す
};

// 検索を実行
console.log("\n「部屋の掃除」を検索中...");
const foundTask = findTaskByTitle(tasks, "部屋の掃除");

// 結果を表示
if (foundTask) {
  console.log("見つかりました:", foundTask);
} else {
  console.log("見つかりませんでした。");
}
```

-   **コードリーディング**
    -   ループの中で`if`文を使い、タイトルが一致するかをチェックします。
    -   一致するものが見つかったら、その場で`return task;`を実行します。`return`が実行されるとループも関数も即座に終了します。
    -   ループが最後まで回りきった（＝見つからなかった）場合は、関数の最後に置かれた`return null;`が実行されます。

--- 

✨ **まとめ**

-   まずアプリケーションの「データ構造」を考えることが、関数設計の第一歩である。
-   「追加」「表示」「検索」など、意味のある操作ごとに処理を関数に分割することで、見通しの良いコードになる。
-   引数、戻り値、デフォルト引数などを組み合わせることで、再利用可能で柔軟な関数を作成できる。
-   グローバルスコープに置く変数は必要最小限にし、関数の引数としてデータを渡すことを基本とするのが良い設計である。

📝 **学習のポイント**

-   [ ] 完了済みのタスクだけ、または未完了のタスクだけを表示する`displayFilteredTasks(tasks, completed)`という関数を作成してみてください。
-   [ ] IDを指定してタスクを削除する`deleteTask(tasks, id)`という関数を作成してみてください。（ヒント: 配列から特定の要素を削除するには`Array.prototype.filter`メソッドが便利です。調べてみましょう！）
-   [ ] なぜこのハンズオンでは、`tasks`配列を関数の引数として毎回渡しているのでしょうか？グローバル変数の`tasks`を関数内で直接参照するのと、どのような違いがあるでしょうか？（ヒント: 関数の独立性、再利用性）
