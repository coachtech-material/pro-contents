# Tutorial 5: JavaScript応用と非同期処理

## Chapter 3: 非同期処理の基礎

### Section 1: 同期処理と非同期処理

🎯 **このセクションで学ぶこと**

-   JavaScriptにおける**同期処理**（Synchronous）と**非同期処理**（Asynchronous）の根本的な違いを理解する。
-   なぜWebフロントエンド開発において非同期処理が不可欠なのかを説明できるようになる。
-   `setTimeout`を使い、非同期処理の基本的な挙動を体験する。

--- 

### イントロダクション：JavaScriptは「シングルスレッド」

これまでの処理は、基本的にコードが書かれた順番通りに、一つずつ実行されてきました。このような処理の実行モデルを**同期処理**と呼びます。一つの処理が終わるまで、次の処理は待機しています。

```javascript
console.log("1. 最初の処理");

// 時間のかかる処理（仮）
for (let i = 0; i < 1000000000; i++) {
  // 何もしないで時間を浪費
}

console.log("2. 次の処理"); // 上のループが終わるまで実行されない
```

このモデルはシンプルで理解しやすいですが、大きな弱点があります。もし、途中で非常に時間のかかる処理（例えば、重い画像のダウンロードや、外部APIからのデータ取得など）が発生した場合、その処理が終わるまで、後続のすべての処理がブロックされてしまいます。Webページで言えば、**画面が固まってフリーズしてしまう**のです。

この問題を解決するのが**非同期処理**です。非同期処理は、時間のかかる処理を「一旦脇に置いて」、その完了を待たずに次の処理へ進むことができる仕組みです。そして、脇に置いておいた処理が完了したら、後からその結果を受け取って、関連する処理を再開します。

JavaScriptは**シングルスレッド**、つまり一度に一つのことしか実行できない言語です。それにもかかわらず、フリーズすることなくスムーズなUIを提供できるのは、この非同期処理の仕組みが言語の根幹に組み込まれているからです。この概念を理解することは、モダンフロントエンド開発において避けては通れない最重要課題の一つです。 

--- 

### ⚙️ 同期処理 (Synchronous)

-   **意味:** 「同」時に「期」を合わせる。処理が一つずつ、順番に実行される。
-   **特徴:**
    -   前の処理が終わるまで、次の処理は待たされる（ブロッキング）。
    -   コードの見た目通りの順番で実行されるため、処理の流れが追いやすい。
-   **例:** これまで学んできたほとんどの処理（変数宣言、計算、`console.log`など）。

**レストランのレジの行列のイメージ:**
一人の客の会計が終わるまで、次の客は待っていなければなりません。

### ⚙️ 非同期処理 (Asynchronous)

-   **意味:** 「同」時に「期」を合わせない。時間のかかる処理の完了を待たずに、次の処理に進む。
-   **特徴:**
    -   時間のかかる処理を待たない（ノンブロッキング）。
    -   UIの応答性を保ち、ユーザー体験を向上させる。
    -   処理の完了順序がコードの記述順序と異なるため、流れが複雑になりがち。
-   **例:**
    -   サーバーとの通信 (`fetch` API)
    -   タイマー処理 (`setTimeout`, `setInterval`)
    -   ファイルの読み込み
    -   ユーザーのイベント（クリックなど）の待機

**レストランの呼び出しベルのイメージ:**
注文を済ませたら、料理ができるのをその場で待ち続けるのではなく、呼び出しベルを受け取って席で待ちます。その間に他の用事（スマホを見るなど）を済ませることができ、ベルが鳴ったら（処理が完了したら）料理を受け取りに行きます。

--- 

### 🧪 `setTimeout`で非同期処理を体験する

`setTimeout`は、指定した時間（ミリ秒）が経過した後に、特定の処理（コールバック関数）を実行する、最もシンプルな非同期APIです。

**基本構文:**
```javascript
setTimeout(コールバック関数, 遅延時間ミリ秒);
```

これを使って、同期処理と非同期処理の挙動の違いを見てみましょう。

```javascript
console.log("1. 料理の注文をしました。");

// 非同期処理：2秒(2000ミリ秒)後に実行される
setTimeout(() => {
  console.log("3. 料理ができました！");
}, 2000);

console.log("2. 席についてスマホを見ています。");
```

**実行結果:**
```
1. 料理の注文をしました。
2. 席についてスマホを見ています。
(2秒後)
3. 料理ができました！
```

-   **重要なポイント:** `setTimeout`は、コールバック関数（`() => { ... }`）の実行を「2秒後に予約」すると、**完了を待たずに**すぐに次の行の`console.log("2. ...")`に進みます。
-   そして、JavaScriptのメインの処理（同期処理）がすべて終わった後、2秒のタイマーが完了したタイミングで、予約されていたコールバック関数が実行されます。

このように、コードの記述順（1→3→2）と、実際の実行順（1→2→3）が異なるのが、非同期処理の最大の特徴です。

--- 

✨ **まとめ**

-   **同期処理**は、処理を上から順番に一つずつ実行し、前の処理が終わるまで次を待つ（ブロッキング）。
-   **非同期処理**は、時間のかかる処理の完了を待たずに次の処理へ進む（ノンブロッキング）。
-   JavaScriptはシングルスレッドでありながら、この非同期処理の仕組みによって、UIのフリーズを防ぎ、スムーズな動作を実現している。
-   `setTimeout`は、非同期処理の基本的な挙動を理解するためのシンプルなAPIである。

📝 **学習のポイント**

-   [ ] 同期処理と非同期処理の違いを、「レストランの行列」や「呼び出しベル」などの比喩を使って説明できますか？
-   [ ] なぜWebサイト、特に今日の複雑なWebアプリケーションにおいて、非同期処理が不可欠なのでしょうか？もし非同期処理がなかったら、どのような問題が起こるか考えてみてください。
-   [ ] `console.log("A"); setTimeout(() => console.log("B"), 0); console.log("C");` というコードの実行結果はどのようになりますか？また、それはなぜですか？（ヒント: `setTimeout`の遅延時間が`0`でも、それは非同期処理として扱われます）
