# Tutorial 5: JavaScript応用と非同期処理

## Chapter 3: 非同期処理の基礎

### Section 2: Promiseの基礎

🎯 **このセクションで学ぶこと**

-   **Promise**とは何か、非同期処理の状態と結果を表現するオブジェクトであることを理解する。
-   Promiseの3つの状態（`pending`, `fulfilled`, `rejected`）を説明できるようになる。
-   `.then()`メソッドを使い、Promiseが成功した（`fulfilled`）後の処理を記述できるようになる。
-   `.catch()`メソッドを使い、Promiseが失敗した（`rejected`）場合のエラーハンドリングを記述できるようになる。

--- 

### イントロダクション：非同期処理の「約束」

`setTimeout`は非同期処理の概念を学ぶのには役立ちましたが、コールバック関数が入れ子になっていくと、コードが非常に読みにくくなるという問題（**コールバック地獄**）がありました。

```javascript
// コールバック地獄の例（今は理解できなくてOK）
step1(function (value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      // ...延々と続く
    });
  });
});
```

この問題を解決し、非同期処理をより構造化され、扱いやすいものにするためにES2015で導入されたのが**Promise**です。

Promiseは、その名の通り「**約束**」を表すオブジェクトです。具体的には、「今はまだ結果は出ていないけれど、いずれ成功（または失敗）の結果を返す」という**未来の処理の状態と結果**をカプセル化します。

レストランの呼び出しベルに例えるなら、Promiseオブジェクトは「呼び出しベルそのもの」です。ベルを持っている状態（結果はまだ）で、ベルが鳴ったら（成功したら）料理を取りに行く、という流れを直感的に記述できます。

--- 

### ⚙️ Promiseの3つの状態

すべてのPromiseオブジェクトは、以下の3つの内部状態のいずれかを取ります。

1.  **`pending` (待機中):**
    -   非同期処理がまだ完了していない初期状態。
    -   呼び出しベルを受け取って、料理ができるのを待っている状態。

2.  **`fulfilled` (成功):**
    -   非同期処理が成功裏に完了した状態。結果の値を持つ。
    -   ベルが鳴り、料理（結果）を受け取れる状態。

3.  **`rejected` (失敗):**
    -   非同期処理が失敗した状態。エラーの理由を持つ。
    -   「品切れでした」と言われ、料理が手に入らなかった状態。

**重要なのは、Promiseの状態は `pending` → `fulfilled` または `pending` → `rejected` の一方通行であり、一度状態が決まったら（settled）、二度と変化しないということです。**

--- 

### ⚙️ Promiseを扱う：`.then()` と `.catch()`

Promiseオブジェクトそのものは、ただの状態を持つ箱にすぎません。その「結果」を使って何かをするためには、専用のメソッドを使います。

#### `.then()`：成功したときの処理を予約する

`.then()`メソッドは、Promiseが`fulfilled`（成功）になったときに実行されるコールバック関数を登録します。コールバック関数の引数には、Promiseが持つ「成功した結果の値」が渡されます。

**例：**
```javascript
// 成功するPromiseを返す関数の例（今はこう書く、と理解する）
const willGetDish = new Promise((resolve, reject) => {
  // 2秒後に成功（resolve）を呼び出す
  setTimeout(() => {
    resolve("美味しいパスタ"); // 成功！結果は"美味しいパスタ"
  }, 2000);
});

console.log("パスタを注文しました。今は pending 状態です。");

willGetDish.then((dish) => {
  // 2秒後、Promiseがfulfilledになると、この部分が実行される
  console.log(`受け取ったもの: ${dish}`);
});

// 出力:
// パスタを注文しました。今は pending 状態です。
// (2秒後)
// 受け取ったもの: 美味しいパスタ
```

#### `.catch()`：失敗したときのエラー処理を予約する

`.catch()`メソッドは、Promiseが`rejected`（失敗）になったときに実行されるコールバック関数を登録します。コールバック関数の引数には、Promiseが持つ「失敗した理由（エラーオブジェクト）」が渡されます。

**例：**
```javascript
// 失敗するPromiseを返す関数の例
const willGetDish = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject("パスタが品切れでした"); // 失敗！理由は"パスタが品切れでした"
  }, 2000);
});

console.log("パスタを注文しました。今は pending 状態です。");

willGetDish
  .then((dish) => {
    // Promiseがrejectedなので、この部分は実行されない
    console.log(`受け取ったもの: ${dish}`);
  })
  .catch((error) => {
    // 2秒後、Promiseがrejectedになると、この部分が実行される
    console.error(`エラー: ${error}`);
  });

// 出力:
// パスタを注文しました。今は pending 状態です。
// (2秒後)
// エラー: パスタが品切れでした
```

`.then()`と`.catch()`を繋げて書くことで、非同期処理の成功と失敗のケースを明確に分離して記述できます。これがメソッドチェーンの強力な点です。

#### `.finally()`：成功・失敗にかかわらず最後に実行する

`.finally()`メソッドは、Promiseの結果が`fulfilled`であろうと`rejected`であろうと、**とにかく最後に必ず**実行したい処理を登録します。ローディング表示を消す、などの後始末処理によく使われます。

```javascript
willGetDish
  .then(dish => { ... })
  .catch(error => { ... })
  .finally(() => {
    console.log("お会計をします。"); // 成功しても失敗しても実行される
  });
```

--- 

✨ **まとめ**

-   **Promise**は、非同期処理の状態（`pending`, `fulfilled`, `rejected`）と結果を保持するオブジェクトである。
-   `.then()`は、Promiseが成功した（`fulfilled`）後の処理をコールバック関数として登録する。
-   `.catch()`は、Promiseが失敗した（`rejected`）後のエラー処理をコールバック関数として登録する。
-   `.finally()`は、成功・失敗にかかわらず、最後に必ず実行される処理を登録する。
-   `.then().catch().finally()` のようにメソッドチェーンで繋げることで、非同期処理のフローを構造的に記述できる。

📝 **学習のポイント**

-   [ ] Promiseが持つ3つの状態をそれぞれ説明してください。
-   [ ] `.then()`と`.catch()`の役割の違いは何ですか？それぞれのコールバック関数が受け取る引数は何ですか？
-   [ ] なぜPromiseを使うと「コールバック地獄」を避けられるのでしょうか？メソッドチェーンというキーワードを使って説明してみてください。
