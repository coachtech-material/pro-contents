# Tutorial 5: JavaScript応用と非同期処理

## Chapter 2: 配列の高度な操作

### Section 3: filterメソッド

🎯 **このセクションで学ぶこと**

-   `filter`メソッドを使い、配列から条件に合う要素だけを抽出した**新しい配列**を作成できるようになる。
-   `map`と`filter`の違いを理解し、適切に使い分けられるようになる。
-   メソッドチェーンを使い、`map`と`filter`を組み合わせて複雑なデータ操作を行えるようになる。

--- 

### イントロダクション：配列から「ふるい分け」する

`map`が配列の要素を「変換」するためのメソッドだったのに対し、`filter`は配列の要素を「**選別**」するためのメソッドです。その名の通り、配列の各要素を特定の条件でふるいにかけ、条件を通過した（`true`になった）要素だけを集めて、新しい配列を作成します。

実務では、以下のような場面で頻繁に使われます。

-   ユーザーの配列から、有効な（`isActive: true`）ユーザーだけを抽出したい。
-   投稿の配列から、特定のカテゴリに属するものだけを絞り込みたい。
-   数値の配列から、偶数だけを取り出したい。

`filter`も`map`と同様に、元の配列を変更しない非破壊的なメソッドであり、Laravelコレクションの`filter`メソッドと全く同じ働きをします。

--- 

### ⚙️ `filter`メソッドの基本構文

`filter`もコールバック関数を引数に取ります。このコールバック関数は、**`true`または`false`を返す**必要があります。

-   コールバック関数が`true`を返した場合、その要素は新しい配列に**含まれます**。
-   コールバック関数が`false`を返した場合、その要素は新しい配列から**除外されます**。

**基本構文:**
```javascript
const newArray = oldArray.filter(コールバック関数);
```

コールバック関数が受け取る引数は`forEach`や`map`と同じです。

```javascript
(要素, インデックス, 元の配列) => {
  // 要素を残す場合は true、除外する場合は false を返す条件式
  return 条件式;
}
```

**例1：数値の配列から偶数だけを抽出する**
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const evenNumbers = numbers.filter((num) => {
  return num % 2 === 0;
});

console.log(evenNumbers); // [2, 4, 6, 8, 10]
console.log(numbers);     // 元の配列は変更されない
```

-   `num % 2 === 0` は、`num`が偶数のときに`true`、奇数のときに`false`を返します。`filter`は、この結果が`true`だった要素だけを集めて新しい配列を作成します。

**例2：ユーザーオブジェクトの配列から20歳以上のユーザーを抽出する**
```javascript
const users = [
  { name: "山田", age: 25 },
  { name: "鈴木", age: 18 },
  { name: "田中", age: 32 },
  { name: "佐藤", age: 19 },
];

// アロー関数の省略記法を使うと、さらに簡潔
const adults = users.filter(user => user.age >= 20);

console.log(adults);
// 出力:
// [
//   { name: "山田", age: 25 },
//   { name: "田中", age: 32 }
// ]
```

--- 

### 🚀 `map`と`filter`の組み合わせ（メソッドチェーン）

`map`や`filter`のような配列メソッドの真価は、それらを**連結（チェーン）**して使える点にあります。`map`も`filter`も新しい配列を返すため、その戻り値に対して、さらに別の配列メソッドを繋げて実行することができます。これを**メソッドチェーン**と呼びます。

**例：20歳以上のユーザーの名前だけを大文字にして配列で取得したい**

このお題は、2つのステップに分解できます。
1.  ユーザーの配列から、20歳以上のユーザーだけを**絞り込む** (`filter`)。
2.  絞り込んだユーザーの配列から、名前だけを**取り出し** (`map`)、さらに大文字に**変換する** (`map`の中の処理)。

これをメソッドチェーンで書くと、以下のようになります。

```javascript
const users = [
  { name: "山田", age: 25 },
  { name: "鈴木", age: 18 },
  { name: "田中", age: 32 },
  { name: "佐藤", age: 19 },
];

const adultNames = users
  .filter(user => user.age >= 20)      // 1. 20歳以上を抽出 -> [{name:"山田",age:25}, {name:"田中",age:32}]
  .map(user => user.name.toUpperCase()); // 2. その結果から名前を取り出し、大文字に変換

console.log(adultNames); // ["YAMADA", "TANAKA"]
```

-   コードが上から下に水のようの流れていくイメージです。
    1.  `users`配列が`filter`に渡される。
    2.  `filter`が返した**新しい配列**（20歳以上のユーザーのみ）が、そのまま次の`map`に渡される。
    3.  `map`が、その配列から名前を取り出して大文字に変換し、**最終的な新しい配列**を返す。

このように、中間変数を使わずに、複数のデータ操作を宣言的かつ流れるように記述できるのが、メソッドチェーンの大きなメリットです。Laravelのコレクション操作に慣れている方にはお馴染みのスタイルでしょう。

--- 

✨ **まとめ**

-   `filter`は、配列の各要素に対してコールバック関数を実行し、その戻り値が`true`であった要素のみからなる**新しい配列を返す**メソッドである。
-   `filter`は、配列から特定の条件に合う要素を「ふるい分け」するために使う。
-   `map`や`filter`のように、新しい配列を返すメソッドは、**メソッドチェーン**として連結させることができる。
-   メソッドチェーンを使うことで、複数のデータ操作を宣言的で簡潔なコードで表現できる。

📝 **学習のポイント**

-   [ ] `const scores = [88, 59, 100, 75, 92];` という点数の配列があります。`filter`を使って、80点以上の合格点だけを抽出した新しい配列`passingScores`を作成してください。
-   [ ] `map`と`filter`のコールバック関数が返す値には、どのような違いがありますか？
-   [ ] 前述の`users`配列から、「10代（ageが10以上20未満）のユーザーの名前」を抽出した配列を、メソッドチェーンを使って作成してみてください。
