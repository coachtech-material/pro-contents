# 5-1-2: 同期処理と非同期処理の違い

## 🎯 このセクションで学ぶこと

- 同期処理と非同期処理の違いを理解する
- なぜ非同期処理が必要なのかを理解する
- コールバック関数の基本を学ぶ

## はじめに

JavaScriptのコードは、基本的に上から下へ順番に実行されます。これを「同期処理」と呼びます。しかし、API通信やファイル読み込みなど、時間のかかる処理を同期的に行うと、その処理が完了するまで次の処理に進めません。この問題を解決するのが「非同期処理」です。

## 1. 同期処理とは

同期処理では、コードが上から下へ順番に実行されます。前の処理が完了するまで、次の処理は待機します。

```javascript
console.log("1. 最初の処理");
console.log("2. 次の処理");
console.log("3. 最後の処理");

// 出力順序:
// 1. 最初の処理
// 2. 次の処理
// 3. 最後の処理
```

### 同期処理の問題点

時間のかかる処理があると、その間、他の処理が止まってしまいます。

```javascript
// 仮に「重い処理」があった場合のイメージ
console.log("1. 処理開始");
// heavyProcess(); // 5秒かかる処理（この間、画面が固まる）
console.log("2. 処理完了");
```

## 2. 非同期処理とは

非同期処理では、時間のかかる処理を「バックグラウンド」で実行し、その間も他の処理を続けることができます。

```javascript
console.log("1. 最初の処理");

// setTimeout は非同期処理
setTimeout(() => {
  console.log("2. 1秒後の処理");
}, 1000);

console.log("3. 最後の処理");

// 出力順序:
// 1. 最初の処理
// 3. 最後の処理
// 2. 1秒後の処理（1秒後に出力）
```

「3. 最後の処理」が「2. 1秒後の処理」より先に出力されることに注目してください。`setTimeout`の中の処理は、1秒後に実行されるため、その間に次の処理が先に実行されます。

## 3. setTimeoutを使った非同期処理

`setTimeout`は、指定した時間（ミリ秒）後に処理を実行する関数です。

```javascript
// 基本構文
setTimeout(() => {
  // 実行したい処理
}, 待機時間（ミリ秒）);

// 例: 2秒後にメッセージを表示
setTimeout(() => {
  console.log("2秒経過しました");
}, 2000);
```

### 複数のsetTimeoutを使った例

```javascript
console.log("カウントダウン開始");

setTimeout(() => {
  console.log("3");
}, 1000);

setTimeout(() => {
  console.log("2");
}, 2000);

setTimeout(() => {
  console.log("1");
}, 3000);

setTimeout(() => {
  console.log("スタート！");
}, 4000);

console.log("（カウントダウン中...）");

// 出力順序:
// カウントダウン開始
// （カウントダウン中...）
// 3（1秒後）
// 2（2秒後）
// 1（3秒後）
// スタート！（4秒後）
```

## 4. コールバック関数

非同期処理が完了した後に実行したい処理は、「コールバック関数」として渡します。

```javascript
// コールバック関数を使った非同期処理
function fetchData(callback) {
  console.log("データ取得開始...");
  
  setTimeout(() => {
    const data = { name: "太郎", age: 25 };
    callback(data); // 処理完了後にコールバック関数を呼び出す
  }, 2000);
}

// 使用例
fetchData((result) => {
  console.log("データ取得完了:", result);
});

console.log("他の処理を続行...");

// 出力順序:
// データ取得開始...
// 他の処理を続行...
// データ取得完了: { name: "太郎", age: 25 }（2秒後）
```

### コールバック地獄

コールバック関数をネストすると、コードが読みにくくなります。これを「コールバック地獄」と呼びます。

```javascript
// コールバック地獄の例（読みにくい）
fetchUser((user) => {
  fetchPosts(user.id, (posts) => {
    fetchComments(posts[0].id, (comments) => {
      fetchLikes(comments[0].id, (likes) => {
        console.log("いいね数:", likes.length);
      });
    });
  });
});
```

この問題を解決するために、次のセクションで学ぶ「Promise」が導入されました。

## 5. 同期処理と非同期処理の比較

| 特徴 | 同期処理 | 非同期処理 |
|------|---------|-----------|
| 実行順序 | 上から下へ順番 | 完了順に実行 |
| 待機 | 前の処理が完了するまで待つ | 待たずに次の処理へ進む |
| 画面の応答性 | 重い処理中は固まる | 重い処理中も操作可能 |
| 主な用途 | 計算、変数操作など | API通信、タイマー、ファイル操作など |

## ✨ まとめ

同期処理はコードが順番に実行されるのに対し、非同期処理は時間のかかる処理をバックグラウンドで実行しながら、他の処理を続けることができます。`setTimeout`やコールバック関数を使って非同期処理を実現できますが、コールバックのネストが深くなると読みにくくなります。

次のセクションでは、この問題を解決する「Promise」について学んでいきましょう。
