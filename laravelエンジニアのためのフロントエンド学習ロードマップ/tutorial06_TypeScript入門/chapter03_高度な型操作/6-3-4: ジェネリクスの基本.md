# 6-3-4: ジェネリクスの基本

## 🎯 このセクションで学ぶこと

- ジェネリクス（Generics）がなぜ必要とされるのか、その動機を理解する
- 型を引数として受け取るジェネリック関数やジェネリッククラスの基本的な作り方を習得する
- `extends` キーワードを使ったジェネリック制約によって、型の安全性をさらに高める方法を学ぶ

## 導入

これまで、関数の引数や戻り値には `string` や `number` のような具体的な型を指定してきました。しかし、もし「受け取った値をそのまま返す」という、どんな型にも対応できる関数を作りたい場合、どうすればよいでしょうか？

```typescript
function identity(arg: any): any {
  return arg;
}
```

`any` を使えば実現できますが、これではTypeScriptの最大の利点である**型安全性**が失われてしまいます。`identity("hello")` の戻り値が `string` であることをTypeScriptは知ることができず、`string` 型のメソッドを補完してくれません。

この「**型安全性を保ちつつ、様々な型に対応できる再利用可能なコンポーネント（関数やクラス）を作りたい**」という要求に応えるのが**ジェネリクス（Generics）**です。ジェネリクスは、型そのものを引数のように動的に扱うことを可能にする、TypeScriptの非常に強力な機能です。

## 詳細解説

### 🔑 ジェネリック関数 (Generic Functions)

ジェネリクスは、関数名やクラス名の後に `<T>` のような形で**型変数（Type Variable）**を宣言することで使用します。この `T` は、関数が呼び出されるときに具体的な型に置き換えられます。

先ほどの `identity` 関数をジェネリクスを使って書き換えてみましょう。

```typescript
// <T> で型変数Tを宣言し、引数argと戻り値の型として使用する
function identity<T>(arg: T): T {
  return arg;
}

// --- 使い方の例 ---

// 1. 型を明示的に指定する
let output1 = identity<string>("myString");
// output1 は string 型

// 2. 型推論に任せる（こちらが一般的）
let output2 = identity("myString");
// output2 は string 型だと推論される

let output3 = identity(123);
// output3 は number 型だと推論される
```

`any` を使った場合との決定的な違いは、**引数の型と戻り値の型の関係性が保たれる**ことです。`identity<string>` を呼び出せば、TypeScriptは戻り値が `string` であることを正確に把握しているため、`output1.toUpperCase()` のようなメソッド呼び出しも安全に行えます。

### 複数の型変数

型変数はカンマ区切りで複数宣言することもできます。

```typescript
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

let result = pair<string, number>("hello", 123);
// result は [string, number] 型
```

### 🔑 ジェネリック制約 (Generic Constraints)

ジェネリクスは非常に柔軟ですが、時には型変数 `T` が**特定のプロパティやメソッドを持つこと**を保証したい場合があります。例えば、「受け取ったオブジェクトの `length` プロパティにアクセスしたい」というケースを考えます。

```typescript
function loggingIdentity<T>(arg: T): T {
  console.log(arg.length); // エラー: Property 'length' does not exist on type 'T'.
  return arg;
}
```

このコードはエラーになります。なぜなら、型 `T` は現時点ではどんな型にもなりうるため、`length` プロパティを持つとは限らないからです（例えば `number` 型など）。

ここで役立つのが**ジェネリック制約**です。`extends` キーワードを使って、型変数が特定のインターフェースを実装していることを強制できます。

```typescript
// lengthプロパティを持つ型を定義
interface Lengthwise {
  length: number;
}

// 型変数Tは、Lengthwiseインターフェースの要件を満たす型でなければならない
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length); // OK! Tには必ずlengthプロパティがあると保証されている
  return arg;
}

loggingIdentity("hello");       // OK. stringはlengthプロパティを持つ
loggingIdentity([1, 2, 3]);     // OK. 配列はlengthプロパティを持つ
// loggingIdentity(123);        // エラー: Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.
```

`T extends Lengthwise` という制約により、`loggingIdentity` 関数は `length` プロパティを持つ型の引数しか受け付けなくなりました。これにより、関数内部で安全に `arg.length` にアクセスできるようになります。

## 💡 TIP

- 型変数名には、慣習的に `T` (Type) が最初の型変数として使われ、以降 `U`, `V` と続きます。しかし、より意味が分かりやすい名前を付けることも推奨されます。例えば、キーと値のペアを扱う場合は `<K, V>` (Key, Value)、要素の型を扱う場合は `<E>` (Element) などがよく使われます。

## ✨ まとめ

- **ジェネリクス**は、型を引数のように扱い、**型安全で再利用可能な**コンポーネントを作成するための機能である。
- `<T>` のように**型変数**を宣言し、それを関数の引数や戻り値の型として使用する。
- TypeScriptの**型推論**により、多くの場合、ジェネリック関数を呼び出す際に型を明示的に指定する必要はない。
- **`extends`** キーワードを使って**ジェネリック制約**を設けることで、型変数が特定の構造を持つことを保証し、より安全なコードを書くことができる。
