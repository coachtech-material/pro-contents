# 6-4-3: TypeScriptのベストプラクティス

## 🎯 このセクションで学ぶこと

- `any` 型の使用を避け、より具体的な型を選ぶべき理由を理解する
- `Type`エイリアスと`Interface`の使い分けの指針を学ぶ
- 型定義をDRY（Don't Repeat Yourself）に保つことの重要性を認識する
- その他、コードの可読性とメンテナンス性を高めるための実践的なヒントを得る

## 導入

TypeScriptの文法や機能を学ぶことは重要ですが、それらをどのように使えば「良いコード」になるのかを知ることは、さらに重要です。良いコードとは、読みやすく、メンテナンスしやすく、バグが入り込みにくいコードです。

このセクションでは、これまで学んだ知識を統合し、より高品質なTypeScriptコードを書くための**ベストプラクティス（最善の実践方法）**をいくつか紹介します。これらは特定の機能の解説ではなく、日々のコーディングにおける心構えや設計思想に近いものです。これらのプラクティスを意識することで、あなたのTypeScriptコードは格段にプロフェッショナルなものになるでしょう。

## 詳細解説

### 1. `any` を避ける (`No `any``)

`any` は、TypeScriptの型チェックを無効にする「最終手段」です。`any` を使うと、どんなプロパティにもアクセスでき、どんな型の変数にも代入できてしまうため、型安全性が完全に失われます。これは、TypeScriptを使うメリットを自ら放棄する行為に他なりません。

**`any` を使いたくなったら、まず立ち止まって考えましょう。**

- **本当に型が不明か？**: APIのレスポンスなど、外部から来るデータで型が不明な場合は、`unknown` 型を使うのがより安全です。`unknown` 型は、`any` と違って、型を絞り込む（Type Guard）までプロパティへのアクセスなどを許可しません。
- **ジェネリクスで解決できないか？**: 様々な型を扱いたい場合は、ジェネリクスを使うことで型安全性を保ったまま柔軟な関数やクラスを定義できます。

```typescript
// BAD: anyは型チェックを放棄する
function process(data: any) {
  console.log(data.name);
}

// GOOD: unknownは型安全。利用前に型のチェックが強制される
function processSafe(data: unknown) {
  if (typeof data === 'object' && data !== null && 'name' in data) {
    // ここで初めて data.name にアクセスできる
    console.log((data as { name: string }).name);
  }
}
```

### 2. `interface` vs `type`: 使い分けの指針

オブジェクトの形状を定義するには `interface` と `type` の2つの方法があります。機能的に重複する部分も多いですが、コミュニティでは以下のような使い分けが一般的です。

- **`interface` を使うべき時**: 
    - オブジェクトの構造を定義する場合（特に、クラスに実装 `implements` されることを意図したオブジェクト）
    - 宣言のマージ（同じ名前の`interface`を複数宣言すると、プロパティが自動的に結合される）機能が必要な場合

- **`type` を使うべき時**: 
    - Union型 (`string | number`)、Intersection型 (`User & Admin`)、タプル型 (`[string, number]`) など、複雑な型を定義する場合
    - プリミティブ型に別名を付けたい場合 (`type UserID = string;`)
    - Utility Typeを使って新しい型を生成する場合 (`type UserPreview = Pick<User, 'id' | 'name'>;`)

**基本的な方針**: 「オブジェクトの形状を定義するなら `interface`、それ以外（Union型など）は `type`」と覚えておくと、多くの場面で迷わずに済みます。

### 3. 型定義をDRYに保つ (Don't Repeat Yourself)

同じような型の定義をコードのあちこちに書くのは避けましょう。これはメンテナンス性の低下に直結します。例えば、あるプロパティの型を変更する際に、すべての箇所を修正し忘れるかもしれません。

- **共通の型はエクスポートする**: 複数のファイルで使われる型は、専用の型定義ファイル（例: `types.ts`）にまとめて、そこから `export` して使い回しましょう。
- **Utility Typesを活用する**: 前のセクションで学んだ `Pick`, `Omit`, `Partial` などを活用し、既存の型から新しい型を派生させましょう。これにより、元の型定義が唯一の信頼できる情報源（Single Source of Truth）となります。

### 4. `as` による型アサーションは慎重に

型アサーション（`value as Type`）は、「コンパイラより私の方がこの型をよく知っている」と宣言する行為です。これは、コンパイラの型チェックを上書きするため、`any` と同様に危険を伴います。

やむを得ず使う場合もありますが（例: `unknown` 型からの絞り込み後）、乱用は避けるべきです。もし `as` を多用しているなら、それは型設計に問題があるサインかもしれません。Type Guardなど、より安全な方法で型を絞り込めないか検討しましょう。

### 5. `const` アサーションでイミュータブルな型を作る

オブジェクトや配列の末尾に `as const` を付けると、すべてのプロパティが `readonly` になり、リテラル型として推論されます。これにより、意図しない変更を防ぎ、より厳密な型定義が可能になります。

```typescript
// as const なし
const config = { env: 'development', version: '1.0' };
// config.env は string 型

// as const あり
const constConfig = { env: 'development', version: '1.0' } as const;
// constConfig.env は 'development' リテラル型

// constConfig.env = 'production'; // エラー: Cannot assign to 'env' because it is a read-only property.
```

設定オブジェクトなど、変更されるべきでないデータに対して非常に有効です。

## ✨ まとめ

- **`any` は最後の手段**: `unknown` やジェネリクスで代替できないか常に検討する。
- **`interface` と `type` の使い分け**: オブジェクトの形状は `interface`、Union型などの複雑な型は `type` を基本とする。
- **DRYな型定義**: 共通の型は一箇所で定義し、Utility Typesを駆使して型を再利用する。
- **型アサーション (`as`) は慎重に**: Type Guardなど、より安全な代替手段を優先する。
- **`as const` を活用**: イミュータブル（不変）なデータを定義し、より厳密な型チェックの恩恵を受ける。
