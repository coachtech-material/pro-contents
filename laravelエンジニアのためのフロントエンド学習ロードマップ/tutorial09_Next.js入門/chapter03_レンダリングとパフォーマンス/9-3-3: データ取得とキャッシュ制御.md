# 9-3-3: データ取得とキャッシュ制御

## 🎯 この章で学ぶこと

- Next.jsにおけるデータ取得とキャッシュ制御の具体的な方法をマスターする。
- `fetch`のキャッシュオプション（`cache`, `next.revalidate`）を使いこなす。
- ルートセグメント単位でのキャッシュ設定方法を理解する。
- オンデマンド再検証によるキャッシュの手動無効化方法を学ぶ。

## はじめに

前のセクションでは、Next.jsが持つ複数のキャッシュレイヤーの概要を学びました。このセクションでは、それらのキャッシュ、特にサーバーサイドの**Data Cache**と**Full Route Cache**を、開発者がどのようにコードレベルで制御できるのかを掘り下げていきます。パフォーマンスを最適化するための具体的な武器を手にいれましょう。

## 1. `fetch`によるData Cacheの制御

App Routerでは、`fetch` APIがNext.jsによって拡張されており、自動的にリクエストの結果をキャッシュする機能が組み込まれています。この挙動は、`fetch`のオプションで細かく制御できます。

### `cache` オプション

-   `'force-cache'` (デフォルト): `fetch`の結果を永続的にキャッシュします。ビルド時に一度取得したデータは、手動でキャッシュを無効化するまで再利用され続けます。これにより、ルートは静的レンダリング（SSG）の対象となります。

    ```jsx
    // デフォルトの挙動。結果は永続的にキャッシュされる。
    const res = await fetch("https://api.example.com/items");
    // 上記は以下と同じ
    const res = await fetch("https://api.example.com/items", { cache: "force-cache" });
    ```

-   `'no-store'`: データを一切キャッシュしません。リクエストごとに常に新しいデータを取得します。この`fetch`を使用したルートは、動的レンダリング（SSR）の対象となります。

    ```jsx
    // 常に最新のデータを取得する
    fetch("https://api.example.com/items", { cache: "no-store" });
    ```

### `next.revalidate` オプション

時間ベースでキャッシュの有効期限を設定したい場合は、`next.revalidate`を使います。これにより、ISR（インクリメンタル静的再生成）が実現されます。

```jsx
// 60秒間キャッシュを有効にする
fetch("https://api.example.com/items", { next: { revalidate: 60 } });
```

この場合、

1.  最初のアクセスでデータを取得し、Data Cacheに保存します。
2.  次の60秒間のアクセスでは、キャッシュされたデータが返されます。
3.  60秒が経過した後の最初のアクセスでは、まず古い（キャッシュされた）データが返され（stale）、その裏側でNext.jsが新しいデータを再取得し、キャッシュを更新します（revalidate）。

## 2. Route Segment Configによるキャッシュ制御

`fetch`単位ではなく、ページ全体やレイアウト単位でキャッシュの挙動を一括で制御したい場合は、**Route Segment Config** を使います。`page.tsx`や`layout.tsx`で、特定の変数をエクスポートすることで設定します。[1]

```jsx
// app/items/page.tsx

// このルート全体を動的レンダリングにする（SSR相当）
export const dynamic = "force-dynamic";

// このルートのキャッシュ有効期間を30秒にする（ISR相当）
export const revalidate = 30;

export default function Page() {
  // このページ内のすべてのfetchはここで定義されたルールに従う
  // ...
}
```

-   `dynamic`: ルートの動的/静的な挙動を強制します。
    -   `'auto'` (デフォルト): Next.jsに挙動を自動判断させる。
    -   `'force-dynamic'`: 強制的に動的レンダリング（SSR）にする。
    -   `'force-static'`: 強制的に静的レンダリング（SSG）にする。動的関数などがあるとビルドエラーになる。
    -   `'error'`: 動的レンダリングの要因があるとビルドエラーにする。
-   `revalidate`: ルート全体のキャッシュの有効期間（秒）を設定します。
    -   `false` (デフォルト): 永続的にキャッシュする。
    -   `0`: キャッシュしない。
    -   `数値`: 秒数指定のISR。

**優先順位**: `fetch`のオプションとRoute Segment Configが競合した場合、より動的な設定が優先されます。（例: `revalidate = 60`のルートで`cache: 'no-store'`の`fetch`を呼ぶと、そのルートは完全に動的になります）。

## 3. キャッシュの無効化（On-demand Revalidation）

CMSでコンテンツを更新したり、DBのデータが変更された際に、時間経過を待たずに手動でキャッシュをクリアしたい場合があります。これを**オンデマンド再検証 (On-demand Revalidation)** と呼びます。

`revalidatePath`や`revalidateTag`といった関数をAPIルートやサーバーアクション内で使うことで、キャッシュを能動的に無効化できます。[2]

### `revalidatePath`

特定のパス（URL）に関連するキャッシュを無効化します。

```jsx
// app/api/revalidate/route.ts
import { NextRequest, NextResponse } from "next/server";
import { revalidatePath } from "next/cache";

export async function POST(request: NextRequest) {
  const { path } = await request.json();

  if (!path) {
    return NextResponse.json({ message: "Path is required" }, { status: 400 });
  }

  // 特定のパスのFull Route Cacheを無効化
  revalidatePath(path);

  return NextResponse.json({ revalidated: true, path, now: Date.now() });
}
```

### `revalidateTag`

`fetch`リクエストにタグを付けておき、そのタグに関連する複数のキャッシュをまとめて無効化できます。より柔軟で強力な方法です。

**Step 1: `fetch`にタグを付ける**
```jsx
// 記事データを取得するfetchに'posts'タグを付ける
fetch(`https://.../posts`, { next: { tags: ["posts"] } });

// ユーザーデータを取得するfetchに'users'タグを付ける
fetch(`https://.../users`, { next: { tags: ["users"] } });
```

**Step 2: タグを指定してキャッシュを無効化**
```jsx
// app/api/revalidate-tag/route.ts
import { NextRequest, NextResponse } from "next/server";
import { revalidateTag } from "next/cache";

export async function POST(request: NextRequest) {
  const { tag } = await request.json();

  if (!tag) {
    return NextResponse.json({ message: "Tag is required" }, { status: 400 });
  }

  // 'posts'タグが付いたすべてのfetchのData Cacheを無効化
  revalidateTag(tag);

  return NextResponse.json({ revalidated: true, tag, now: Date.now() });
}
```

これにより、「ブログ記事が更新されたら、記事一覧ページと記事詳細ページの両方のキャッシュをクリアする」といった複雑なキャッシュ管理が容易になります。

## ✨ まとめ

-   `fetch`の`cache`と`next.revalidate`オプションが、データ取得レベルでのキャッシュ戦略の基本となる。
-   Route Segment Config (`dynamic`, `revalidate`) を使うと、ページやレイアウト単位でキャッシュ戦略を宣言的に設定できる。
-   `revalidatePath`と`revalidateTag`を使うことで、外部イベントをトリガーにして能動的にキャッシュを無効化（更新）できる。
-   静的（`force-cache`）、動的（`no-store`）、ISR（`revalidate`）を適切に使い分けることが、パフォーマンスとコンテンツの鮮度を両立させる鍵である。

---

## 参考文献

[1] Next.js Documentation. (n.d.). *Route Segment Config*. Retrieved from https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config
[2] Next.js Documentation. (n.d.). *On-Demand Revalidation*. Retrieved from https://nextjs.org/docs/app/building-your-application/caching#on-demand-revalidation
