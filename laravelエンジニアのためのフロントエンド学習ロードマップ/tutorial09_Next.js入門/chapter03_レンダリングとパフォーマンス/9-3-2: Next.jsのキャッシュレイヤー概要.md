# 9-3-2: キャッシュ戦略

## 🎯 このセクションで学ぶこと

-   Next.jsが持つ複数のキャッシュレイヤーの存在を理解する
-   サーバーサイドの**Data Cache**と**Full Route Cache**の役割と違いを学ぶ
-   クライアントサイドの**Router Cache**の役割を学ぶ
-   これらのキャッシュがどのように連携し、アプリケーションのパフォーマンスを向上させているかを理解する

## 導入

Next.jsの驚異的なパフォーマンスは、その高度で多層的なキャッシュ戦略によって支えられています。前のセクションで、`fetch`のオプションがレンダリング手法を決定すること、そしてそれがキャッシュと密接に関連していることを見ました。しかし、Next.jsのキャッシュは単一の仕組みではありません。サーバーサイドとクライアントサイドにまたがる複数のレイヤーで構成されており、それぞれが異なる役割を担っています。

このセクションでは、Next.jsのキャッシュシステムの全体像を解き明かします。特に重要な以下の3つのキャッシュレイヤーに焦点を当て、それぞれの役割と相互作用を理解することで、より高度なパフォーマンスチューニングを行うための知識を身につけます。

1.  **Data Cache** (サーバーサイド): `fetch`リクエストの結果を保存する。
2.  **Full Route Cache** (サーバーサイド): ページのレンダリング結果（RSC PayloadとHTML）を保存する。
3.  **Router Cache** (クライアントサイド): ユーザーが訪れたページのレンダリング結果をブラウザのメモリに保存する。

## 詳細解説

### 1. Data Cache (データキャッシュ)

Data Cacheは、サーバーサイドで`fetch`リクエストの結果を永続的に保存するためのキャッシュです。これは、Next.jsのビルドプロセスやサーバー環境に組み込まれており、複数のリクエストやデプロイメントをまたいでデータを保持することができます（Vercelのようなホスティング環境の場合）。

-   **対象**: `fetch` APIによるデータ取得の結果。
-   **制御方法**: `fetch`のオプション（`cache: 'force-cache'`, `cache: 'no-store'`, `next: { revalidate: n }`）で制御します。
-   **役割**: 同じデータソースへの重複したリクエストを防ぎ、ビルド時間やレンダリング時間を短縮します。例えば、レイアウトとページの両方で同じ`fetch`リクエストを呼び出しても、実際のリクエストは一度しか実行されません。

```tsx
// このfetchの結果はData Cacheに保存される
await fetch("https://...", { next: { revalidate: 60 } });
```

### 2. Full Route Cache (フルルートキャッシュ)

Full Route Cacheもサーバーサイドのキャッシュですが、こちらは**ページのレンダリング結果そのもの**をキャッシュします。静的にレンダリング可能なルート（`fetch`が`force-cache`を使用し、動的関数を含まないルート）が対象です。

-   **対象**: React Server Component (RSC) の出力（ペイロード）と、その結果生成されたHTML。
-   **タイミング**: ビルド時に生成され、CDNに配置されます。
-   **役割**: ユーザーからのリクエストに対して、レンダリング処理を一切行わず、事前に生成されたHTMLとRSCペイロードを即座に返すことで、最速のレスポンスを実現します。
-   **無効化 (Invalidation)**: `fetch`で`cache: 'no-store'`や`revalidate`が使われている場合、または`cookies()`のような動的関数が使われている場合、そのルートはFull Route Cacheの対象外となり、リクエストごとに動的にレンダリングされます。

Full Route Cacheは、SSG（静的サイト生成）の核となるキャッシュです。ユーザーがページにアクセスしたとき、Next.jsサーバーはまずFull Route Cacheを確認し、ヒットすればレンダリングをスキップしてキャッシュを返します。

### 3. Router Cache (ルーターキャッシュ)

Router Cacheは、これまでの2つとは異なり、**クライアントサイド（ユーザーのブラウザ）** に存在するキャッシュです。ユーザーがアプリケーション内をナビゲーションする際の体験を高速化するために設計されています。

-   **対象**: ユーザーが訪れたルートのRSCペイロード。
-   **タイミング**: ユーザーが`<Link>`コンポーネントを使ってページ間を移動した際に、RSCペイロードがメモリに保存されます。
-   **役割**: ユーザーが一度訪れたページに再度アクセスした際、サーバーにリクエストを送ることなく、ブラウザのメモリに保存されたRSCペイロードを使って即座にページを描画します。これにより、「戻る」「進む」の操作や再訪が非常に高速になります。
-   **持続時間**: セッション中のみ保持されます。ページをリロードするとキャッシュは破棄されます。
-   **プリフェッチ**: `<Link>`コンポーネントがビューポートに入ると、Next.jsはリンク先のページのRSCペイロードを自動的に**プリフェッチ（事前取得）**してRouter Cacheに保存します。これにより、ユーザーがリンクをクリックしたときには、すでにデータが手元にある状態になり、瞬時にページ遷移が完了します。

### キャッシュの連携フロー

これらのキャッシュは、以下のように連携して動作します。

1.  **ビルド時**: Next.jsは静的なルートを検出し、`fetch`リクエストを実行します。その結果は**Data Cache**に保存されます。そして、そのデータを使ってページをレンダリングし、結果（HTMLとRSCペイロード）を**Full Route Cache**に保存します。

2.  **ユーザーが初めてページにアクセス**: リクエストがサーバーに届きます。
    -   **静的ルートの場合**: サーバーは**Full Route Cache**からHTMLとRSCペイロードを取得し、即座にクライアントに返します。クライアントは受け取ったRSCペイロードを**Router Cache**に保存します。
    -   **動的ルートの場合**: サーバーはレンダリングを開始します。`fetch`を実行する際、まず**Data Cache**を確認し、有効なキャッシュがあればそれを使います。なければAPIなどにリクエストを送り、結果を**Data Cache**に保存します。最終的にレンダリングされたHTMLとRSCペイロードをクライアントに返し、クライアントはそれを**Router Cache**に保存します。

3.  **ユーザーが別のページに遷移 (`<Link>`)**: ユーザーがリンクをクリックすると、クライアントはまず**Router Cache**を確認します。キャッシュがあれば、サーバーへのリクエストなしでページを即座に描画します。キャッシュがなければ、サーバーにRSCペイロードをリクエストします（このフローは2.と同じ）。

4.  **ユーザーが「戻る」ボタンでページに戻る**: ブラウザは**Router Cache**からページを復元するため、瞬時に表示が完了します。

## ✨ まとめ

-   Next.jsは、パフォーマンスを最大化するために、複数のキャッシュレイヤーを効果的に利用している。
-   **Data Cache**は`fetch`の結果をサーバーサイドで永続化し、データソースへの不要なアクセスを削減する。
-   **Full Route Cache**は静的ページのレンダリング結果をサーバーサイド（CDN）にキャッシュし、最速の初回表示を実現する（SSGの核）。
-   **Router Cache**はユーザーのブラウザメモリにRSCペイロードをキャッシュし、アプリケーション内のナビゲーションを瞬時に行う。
-   これらのキャッシュ戦略を理解することは、Next.jsアプリケーションのパフォーマンスのボトルネックを特定し、最適化を行う上で不可欠である。
