# 9-2-2: 動的ルーティング

## 🎯 このセクションで学ぶこと

-   静的ルートだけでは対応できない動的なURL（例: ブログ記事、商品詳細ページ）の必要性を理解する
-   角括弧 `[]` を使って、URLの一部を動的なパラメータとして受け取る方法（Dynamic Segments）を習得する
-   コンポーネント内で動的パラメータを `params` オブジェクトから受け取る方法を学ぶ
-   複数のURLセグメントを一度にキャッチする `[...slug]` (Catch-all Segments) の使い方を理解する
-   親ルートも含めてキャッチする `[[...slug]]` (Optional Catch-all Segments) の使い方を学ぶ

## 導入

前のセクションでは、ファイルベースルーティングを使って静的なパス（例: `/about`, `/dashboard`）を作成する方法を学びました。しかし、実際のアプリケーションでは、URLの一部が動的に変わるケースがほとんどです。

-   ブログ記事: `/blog/my-first-post`, `/blog/react-hooks-deep-dive`
-   商品詳細: `/products/123`, `/products/456`
-   ユーザープロフィール: `/users/john-doe`, `/users/jane-doe`

これらのように、IDやスラッグ（URLフレンドリーな文字列）に基づいて表示するコンテンツが変わるページを、一つ一つ静的なフォルダとして作成するのは現実的ではありません。この問題を解決するのが**動的ルーティング (Dynamic Routing)** です。

## 詳細解説

### 🔑 動的セグメント (Dynamic Segments)

Next.jsでは、フォルダ名を角括弧 `[]` で囲むことで、その部分を動的なセグメントとして定義できます。例えば、`[slug]`や`[id]`のようにします。

#### 例：ブログ記事ページ

ブログ記事の詳細ページを考えてみましょう。URLが`/blog/記事のスラッグ`となるようにしたい場合、以下のようなフォルダ構造になります。

```
app/
└── blog/
    └── [slug]/         # `slug`という名前の動的セグメント
        └── page.tsx    # /blog/:slug に対応するページコンポーネント
```

この設定により、`/blog/hello-world`や`/blog/learning-nextjs`といったURLへのアクセスは、すべて`app/blog/[slug]/page.tsx`で処理されます。

#### パラメータの受け取り

`page.tsx`コンポーネントは、`params`という名前のpropsを受け取ります。このオブジェクトに、URLから抽出された動的パラメータが格納されます。

```tsx
// app/blog/[slug]/page.tsx

// paramsの型を定義するのがベストプラクティス
interface PostPageProps {
  params: {
    slug: string; // フォルダ名 `[slug]` に対応
  };
}

// `params` をpropsとして受け取る
export default function PostPage({ params }: PostPageProps) {
  const { slug } = params;

  // このslugを使って、データベースやAPIから特定の記事データを取得する
  // const post = await getPostBySlug(slug);

  return (
    <div>
      <h1>Blog Post: {slug}</h1>
      {/* ここに記事の内容を表示 */}
    </div>
  );
}
```

`params`オブジェクトのキーは、角括弧で囲んだフォルダ名（この場合は`slug`）と一致します。

### `generateStaticParams` による静的生成

動的セグメントを持つページは、デフォルトではリクエスト時にサーバーサイドでレンダリングされます（SSR）。しかし、ブログ記事のように、ビルド時にすべての可能なパスが分かっている場合、`generateStaticParams`関数をエクスポートすることで、ビルド時にすべてのページを静的に生成（SSG）しておくことができます。これにより、パフォーマンスが大幅に向上します。

```tsx
// app/blog/[slug]/page.tsx

// この関数をエクスポートすると、ビルド時に各ページが静的生成される
export async function generateStaticParams() {
  // 例: APIからすべての記事のスラッグを取得
  const posts = await fetch("https://.../posts").then((res) => res.json());

  // Next.jsが期待する形式 [{ slug: 'post-1' }, { slug: 'post-2' }, ...]
  return posts.map((post) => ({
    slug: post.slug,
  }));
}

// ... PostPageコンポーネントは同じ
```

### 📚 Catch-all Segments

複数のパスセグメントをまとめてキャッチしたい場合もあります。例えば、ドキュメントサイトで`/docs/getting-started/installation`のようなURLを考えます。この場合、`getting-started`と`installation`の部分をまとめて取得したいでしょう。

このようなケースでは、角括弧の中に三点リーダー `...` を付けたフォルダ名を使います。これを**Catch-all Segments**と呼びます。

-   フォルダ名: `[...slug]`
-   URL: `/docs/a/b/c`
-   `params`: `{ slug: ["a", "b", "c"] }`

```tsx
// app/docs/[...slug]/page.tsx

interface DocsPageProps {
  params: {
    slug: string[]; // パラメータは文字列の配列になる
  };
}

export default function DocsPage({ params }: DocsPageProps) {
  const path = params.slug.join("/"); // "a/b/c"

  return (
    <div>
      <h1>Documentation for: {path}</h1>
    </div>
  );
}
```

### 📖 Optional Catch-all Segments

Catch-all Segmentsは、少なくとも1つのセグメントが存在するURLにしかマッチしません。例えば、`app/docs/[...slug]/page.tsx`は`/docs`というURLにはマッチしません。

親ルート（この場合は`/docs`）も含めて、すべてのパスをキャッチしたい場合は、フォルダ名を二重の角括弧 `[[]]` で囲みます。これを**Optional Catch-all Segments**と呼びます。

-   フォルダ名: `[[...slug]]`
-   URL: `/docs` → `params`: `{ slug: undefined }`
-   URL: `/docs/a/b` → `params`: `{ slug: ["a", "b"] }`

これは、例えば`/shop`という商品一覧ページと、`/shop/category/product`のような絞り込みページを同じコンポーネントで処理したい場合に便利です。

## ✨ まとめ

-   URLの一部が動的に変わるルートを作成するには、フォルダ名を角括弧 `[]` で囲んだ**動的セグメント**を使用する（例: `[slug]`）。
-   ページコンポーネントは `params` propsを受け取り、URLから抽出された動的な値にアクセスできる。
-   複数のURLセグメントを配列としてキャッチするには、`[...slug]` のような **Catch-all Segments** を使用する。
-   親ルートも含めてすべてをキャッチするには、`[[...slug]]` のような **Optional Catch-all Segments** を使用する。
-   これらの動的ルーティング機能を活用することで、ブログ、ECサイト、ドキュメントサイトなど、あらゆる種類のWebアプリケーションのURL構造を柔軟に構築できる。
