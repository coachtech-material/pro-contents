
# Col-3-3: Partial Prerendering (PPR) の概念

## 🎯 このセクションで学ぶこと

-   Partial Prerendering (PPR) が解決しようとする、静的と動的のトレードオフを理解する。
-   PPRの基本的な仕組みと、「静的なシェル」の概念を学ぶ。
-   `Suspense` がPPRでどのように活用されるかを理解する。
-   PPRがもたらす開発者体験とユーザー体験の向上について学ぶ。

## 導入: 静的と動的の究極のジレンマ

これまで見てきたように、Webレンダリングには大きなトレードオフが存在しました。

-   **静的レンダリング (SSG)**: パフォーマンスは最高だが、動的なコンテンツに対応しづらい。
-   **動的レンダリング (SSR)**: パーソナライズされた動的なコンテンツに対応できるが、パフォーマンスは静的に劣る（特にTTFB）。

多くのWebページは、この両方の性質を併せ持っています。例えば、ECサイトの商品ページを考えてみましょう。

-   **静的な部分**: ヘッダー、フッター、商品の説明、レビュー欄のレイアウトなど、ほとんどのユーザーで共通の部分。
-   **動的な部分**: ログインしているユーザー名、カートに入っている商品の数、パーソナライズされたおすすめ商品など、ユーザーごとに異なる部分。

従来のアプローチでは、ページ内に一つでも動的な要素があれば、ページ全体を動的レンダリング（SSR）するしかありませんでした。これにより、高速に表示できるはずの静的な部分まで、動的レンダリングのパフォーマンスに引きずられていました。

**Partial Prerendering (PPR)** は、この長年のジレンマを解決するためにNext.js 14で導入された、新しいレンダリングモデルです。[1]

## PPRとは？

PPRは、**「ページの大部分を静的に事前レンダリングしつつ、一部の動的な部分だけをリクエスト時にレンダリングする」** という、静的と動的のハイブリッドアプローチです。

これにより、静的サイトの高速なロードパフォーマンスと、動的アプリケーションのインタラクティブ性を、一つのページで両立させることができます。

## PPRの仕組み: 静的なシェルと動的なホール

PPRは、Reactの`<Suspense>`を基盤として動作します。

1.  **ビルド時**: ビルド時に、ページは**「静的なシェル (Static Shell)」**として事前レンダリング（Prerender）されます。このシェルには、ページのすべての静的な部分（レイアウト、テキストなど）が含まれます。

2.  **動的なホールの定義**: `<Suspense>`でラップされた部分が、**「動的なホール (Dynamic Hole)」**として扱われます。ビルド時には、このホールのフォールバックUIが静的シェルに埋め込まれます。

3.  **リクエスト時**: ユーザーからリクエストが来ると、
    a.  まず、CDNから**静的なシェルが即座に**クライアントに返されます。ユーザーはページの骨格を瞬時に見ることができます（TTFBが非常に速い）。
    b.  同時に、Next.jsサーバーは動的なホールの中身（`<Suspense>`の子コンポーネント）をレンダリングします。
    c.  動的なホールのレンダリングが完了すると、その結果が静的なシェルを配信したのと同じHTTPストリームを使ってクライアントに送信されます。
    d.  クライアントのReactが、静的シェルに埋め込まれているフォールバックUIを、ストリーミングされてきた動的なコンテンツに置き換えます。

![PPRの概念図](https://raw.githubusercontent.com/coachtech-material/pro-contents/main/laravel%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E5%AD%A6%E7%BF%92%E3%83%AD%E3%83%BC%E3%83%89%E3%83%9E%E3%83%83%E3%83%97/images/column/ppr-flow.png)

**重要なのは、開発者はPPRを意識して特別なコードを書く必要がないということです。** `Suspense`を使ってローディングUIを適切に設定するだけで、Next.jsが自動的にPPRを適用してくれます。

```jsx
// app/products/[id]/page.tsx

import { Suspense } from 'react';
import { ProductDescription, Reviews, AddToCartButton } from './components';

export default function ProductPage({ params }) {
  return (
    <div>
      {/* この部分は静的シェルの一部として事前レンダリングされる */}
      <ProductDescription productId={params.id} />
      <hr />

      {/* Suspenseで囲まれた部分が動的なホールになる */}
      <Suspense fallback={<Spinner />}>
        <Reviews productId={params.id} />
      </Suspense>

      <Suspense fallback={<button disabled>Loading...</button>}>
        <AddToCartButton productId={params.id} />
      </Suspense>
    </div>
  );
}
```

この例では、商品の説明(`ProductDescription`)は静的なシェルとしてビルド時にレンダリングされます。一方、レビュー(`Reviews`)やカート追加ボタン(`AddToCartButton`)は、リクエスト時にユーザー情報などに基づいて動的にレンダリングされ、ストリーミングで配信されます。

## PPRのメリット

### 1. パフォーマンスの向上

ページの大部分が静的に配信されるため、TTFBが劇的に改善されます。ユーザーはすぐに意味のあるコンテンツを見ることができ、体感速度が大幅に向上します。

### 2. 開発者体験のシンプルさ

開発者は「このページはSSGにすべきか、SSRにすべきか」と悩む必要がなくなります。コンポーネントごとに静的か動的かを考えるだけでよく、Next.jsが最適なレンダリング方法を自動で判断してくれます。

> PPR を使用すると、静的ページと動的ページという 2 つの概念は必要ありません。動的な部分を持つ静的ページだけが存在します。
> --- Vercel, "What is Partial Prerendering (PPR)?" [2]

### 3. 動的コンテンツと静的コンテンツの共存

これまで難しかった、一つのページ内での静的コンテンツの高速配信と、パーソナライズされた動的コンテンツのスムーズな統合を、最適な形で実現します。

## ✨ まとめ

-   **PPR**は、静的レンダリングのパフォーマンスと動的レンダリングの柔軟性を両立させる、Next.js 14の新しいレンダリングモデル。
-   ページの大部分を**「静的なシェル」**としてビルド時に事前レンダリングし、`<Suspense>`で囲まれた部分を**「動的なホール」**としてリクエスト時にレンダリングする。
-   これにより、TTFBを最小限に抑えつつ、パーソナライズされたコンテンツをページに含めることが可能になる。
-   開発者はレンダリング戦略全体を考えるのではなく、コンポーネント単位での静的/動的の区別に集中できる。
-   PPRは、RSC、Streaming、Suspenseといった技術の集大成であり、モダンなWebアプリケーションの新しいスタンダードとなる可能性を秘めている。

このカラムで学んだレンダリング戦略の知識は、あなたが今後フロントエンドエンジニアとしてパフォーマンスとユーザー体験を追求していく上で、非常に強力な武器となるでしょう。

---

## 参考文献

[1] Next.js. (2023, October 26). *Next.js 14*. Retrieved from https://nextjs.org/blog/next-14

[2] Vercel. (n.d.). *What is Partial Prerendering (PPR)?*. Retrieved from https://vercel.com/docs/getting-started-with-vercel/concepts/rendering#partial-prerendering-ppr-alpha
