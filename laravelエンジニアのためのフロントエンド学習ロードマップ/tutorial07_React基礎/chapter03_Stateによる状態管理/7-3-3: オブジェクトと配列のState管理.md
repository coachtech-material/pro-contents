# 7-3-3: オブジェクトと配列のState管理

## Chapter 3: Stateによる状態管理

### Section 3: オブジェクトと配列のState管理

🎯 **このセクションで学ぶこと**

-   オブジェクトや配列といった非プリミティブな値をStateで扱う際の注意点（**Immutability**）を理解する。
-   JavaScriptのスプレッド構文 (`...`) を使って、オブジェクトや配列のStateを**イミュータブル（不変）**に更新する方法を習得する。
-   配列Stateに対して、要素の追加・削除・更新をイミュータブルに行う方法を習得する。

--- 

### イントロダクション：複雑なStateの落とし穴

Stateとして扱いたいデータは、数値や文字列のような単純な値（プリミティブ値）だけではありません。ユーザー情報のオブジェクトや、TODOリストの配列など、より複雑な構造を持つデータを扱う場面は非常に多いです。

しかし、オブジェクトや配列をStateとして扱う際には、Reactの重要な原則である **Immutability（不変性）** を理解していないと、予期せぬバグに繋がります。「Stateを更新したはずなのに、画面が再レンダリングされない」という問題の多くは、これが原因です。

このセクションでは、オブジェクトと配列のStateを安全に更新するための正しい方法を学びます。

--- 

### ⚙️ Immutability（不変性）の原則

Reactでは、**Stateを直接変更（mutate）してはいけません**。これは、オブジェクトや配列のStateを扱う際に特に重要です。

JavaScriptでは、オブジェクトや配列は参照によって扱われます。つまり、変数が保持しているのはデータそのものではなく、メモリ上のデータが置かれている場所（アドレス）です。

**❌ やってはいけないこと（Stateの直接変更）:**
```tsx
const [user, setUser] = useState({ name: 'Taro', age: 20 });

const handleAgeIncrement = () => {
  // ダメ！ userオブジェクトのプロパティを直接変更している
  user.age = user.age + 1; 
  setUser(user); // Reactは変更を検知できない！
};
```

なぜこれがダメなのでしょうか？
`setUser(user)`を呼び出しても、渡されている`user`変数が指し示すメモリ上のアドレスは、更新前と後で変わっていません。Reactは、Stateの変更を検知するために、前回のStateと今回のStateを比較しますが、この比較は高速化のために参照（アドレス）の比較で行われます。アドレスが変わっていないため、Reactは「何も変更されていない」と判断し、**再レンダリングを行わない**のです。

**⭕ 正しい方法：新しいオブジェクトを作成する**

Stateを更新する際は、元のオブジェクトや配列を変更するのではなく、**新しいオブジェクトや配列を作成し**、それをセッター関数に渡す必要があります。この操作を**イミュータブルな更新**と呼びます。

--- 

### 🚀 スプレッド構文によるイミュータブルな更新

イミュータブルな更新を簡単に行うために、JavaScriptの**スプレッド構文 (`...`)** を活用します。

#### オブジェクトの更新

```tsx
const [user, setUser] = useState({ name: 'Taro', age: 20 });

const handleAgeIncrement = () => {
  // スプレッド構文で新しいオブジェクトを作成
  setUser({ 
    ...user, // 1. 元のuserオブジェクトの全プロパティを展開
    age: user.age + 1 // 2. 更新したいプロパティだけを上書き
  });
};
```

-   `{ ...user }` は、`user`オブジェクトが持つすべてのプロパティ（`name: 'Taro'`, `age: 20`）を新しいオブジェクトの中にコピーします。
-   その直後に `, age: user.age + 1` と記述することで、`age`プロパティだけが新しい値で上書きされます。
-   結果として、`{ name: 'Taro', age: 21 }` という**全く新しいオブジェクト**が生成され、`setUser`に渡されます。Reactは参照が変わったことを検知し、正しく再レンダリングを行います。

#### 配列の更新

配列のStateも同様に、`push`や`splice`のような配列を直接変更するメソッドは使えません。スプレッド構文や、`map`, `filter`のような新しい配列を返すメソッドを使います。

**例：TODOリスト**

```tsx
const [todos, setTodos] = useState([
  { id: 1, text: 'Reactを学ぶ' },
  { id: 2, text: '寝る' },
]);

// 1. 要素の追加
const addTodo = (newTodoText: string) => {
  const newTodo = { id: Date.now(), text: newTodoText };
  // 元の配列を展開し、末尾に新しい要素を追加した「新しい配列」を作成
  setTodos([...todos, newTodo]);
};

// 2. 要素の削除 (idが2のものを削除)
const deleteTodo = (idToDelete: number) => {
  // filterは条件に合う要素だけを集めた「新しい配列」を返す
  setTodos(todos.filter(todo => todo.id !== idToDelete));
};

// 3. 要素の更新 (idが1のもののtextを更新)
const updateTodo = (idToUpdate: number, newText: string) => {
  // mapは各要素を変換した「新しい配列」を返す
  setTodos(todos.map(todo => {
    if (todo.id === idToUpdate) {
      // 更新対象の要素の場合、新しいオブジェクトを返す
      return { ...todo, text: newText };
    } else {
      // それ以外は元の要素をそのまま返す
      return todo;
    }
  }));
};
```

--- 

✨ **まとめ**

-   オブジェクトや配列のStateを更新する際は、**Immutability（不変性）**の原則に従う必要がある。
-   Stateを直接変更（mutate）するのではなく、常に**新しいオブジェクトや配列を作成**してセッター関数に渡す。
-   **スプレッド構文 (`...`)** を使うことで、イミュータブルな更新を簡潔に記述できる。
    -   オブジェクトの更新: `setObj({ ...obj, key: newValue })`
    -   配列への追加: `setArr([...arr, newItem])`
-   配列の削除や更新には、新しい配列を返す`filter`や`map`メソッドが非常に便利である。

📝 **学習のポイント**

-   [ ] なぜReactは、Stateの変更検知に、オブジェクトの中身全体の比較ではなく、参照の比較を行うのでしょうか？その理由をパフォーマンスの観点から考えてみましょう。
-   [ ] `const arr1 = [1, 2, 3]; const arr2 = arr1; arr2.push(4);` としたとき、`arr1`の中身はどうなっているでしょうか？ JavaScriptの参照の概念を再確認しましょう。
-   [ ] 配列の先頭に要素を追加するには、スプレッド構文をどのように使えばよいでしょうか？
