
# Col-2-4: Incremental Static Regeneration (ISR)

## 🎯 このセクションで学ぶこと

-   ISRの基本的な仕組みと、SSGとSSRのハイブリッドである理由を理解する。
-   ISRのメリット（ビルド時間の短縮、コンテンツの鮮度維持）とデメリットを学ぶ。
-   `revalidate`オプションの役割と、オンデマンドISRについて理解する。

## 導入

静的サイト生成（SSG）は最高のパフォーマンスを提供しますが、サイトの規模が大きくなるとビルド時間が長くなるという大きな課題がありました。また、コンテンツを更新するためにはサイト全体を再ビルドする必要がありました。

この問題を解決するためにNext.jsによって導入されたのが、**インクリメンタル静的再生成（Incremental Static Regeneration, ISR）**です。ISRは、SSGのパフォーマンスとSSRの動的性を組み合わせた、革新的なハイブリッドアプローチです。[1]

## ISRの仕組み

ISRは、SSGをベースにしながら、**一定期間が経過した後にページをバックグラウンドで再生成する**仕組みです。これにより、大規模なサイトでもビルド時間を短縮しつつ、コンテンツの鮮度を保つことができます。

ISRの処理フローは以下のようになります。

1.  **Initial Build**: SSGと同様に、ビルド時に主要なページや一部のページのHTMLを生成しておきます。すべてのページをビルドする必要はありません。
2.  **First Request**: ユーザーがページにアクセスします。
    -   **もしページがビルド済みの場合**: CDNから即座に静的HTMLが返されます（SSGと同じ）。
    -   **もしページが未ビルドの場合**: サーバーは初回リクエスト時にページをレンダリングし（SSRと同じ）、生成したHTMLをユーザーに返しつつ、CDNにキャッシュします。2回目以降のアクセスはCDNから配信されます。
3.  **Revalidation**: ページには**有効期限（例: 60秒）**が設定されています。ユーザーが有効期限切れのページにアクセスすると、
    -   まず、古い（キャッシュされた）HTMLが即座にユーザーに返されます（表示速度は速いまま）。
    -   **その裏側で**、Next.jsはページを再生成する処理を開始します。
    -   再生成が完了すると、CDNのキャッシュが新しいページで上書きされます。
    -   次にそのページにアクセスしたユーザーには、更新されたコンテンツが表示されます。

この「古いコンテンツを返しながら裏で更新する」挙動は、`stale-while-revalidate`というキャッシュ戦略として知られています。

![ISRの処理フロー](https://raw.githubusercontent.com/coachtech-material/pro-contents/main/laravel%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E5%AD%A6%E7%BF%92%E3%83%AD%E3%83%BC%E3%83%89%E3%83%9E%E3%83%83%E3%83%97/images/column/isr-flow.png)

Next.jsでは、`getStaticProps`から返すオブジェクトに`revalidate`プロパティを追加するだけでISRを有効にできます。

```javascript
export async function getStaticProps() {
  const res = await fetch('https://...');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    // 60秒ごとにページの再生成を試みる
    revalidate: 60,
  };
}
```

## ISRのメリット

### 1. ビルド時間の劇的な短縮

ISRを使えば、ビルド時にすべてのページを生成する必要がなくなります。例えば、10万件の商品ページがあるECサイトでも、ビルド時には0件のページを生成し、アクセスがあったページから順次生成していくことができます。これにより、ビルド時間は数秒から数分に抑えられます。

### 2. コンテンツの鮮度とパフォーマンスの両立

SSGの高速な配信性能を維持しつつ、コンテンツを شبه-リアルタイムに更新できます。ユーザーは常に高速なレスポンスを得られ、バックグラウンドでの再生成によりコンテンツも最新の状態に保たれます。

> ISRは、静的サイトのメリット（常に高速、常にオンライン、グローバルに分散）と、動的にレンダリングされたコンテンツのメリット（ヘッドレスCMS、eコマースなどからコンテンツを取得）を両立させます。
> --- Vercel, "Incremental Static Regeneration (ISR)" [2]

### 3. オンデマンドISRによる即時更新

時間ベースの再生成に加えて、Next.jsでは特定のイベント（例: CMSでのコンテンツ更新）をトリガーに、特定のページだけを能動的に再生成する**オンデマンドISR**もサポートしています。これにより、更新を即座にサイトに反映させることが可能になります。

## ISRのデメリット

### 1. コンテンツの一貫性

ISRでは、タイミングによって一部のユーザーが古いコンテンツを見ることがあります。これは`stale-while-revalidate`戦略の特性ですが、金融情報や在庫情報など、常に最新の情報が求められる厳格な要件を持つアプリケーションには向かない場合があります。

### 2. ホスティング環境への依存

ISRはNext.jsが提供する比較的高度な機能であり、その能力を最大限に引き出すにはVercelやNetlifyといった対応するホスティングプラットフォームを利用することが推奨されます。自前のサーバーでISR環境を構築するのは複雑になる可能性があります。

## ✨ まとめ

-   ISRは、SSGのパフォーマンスとSSRの動的性を組み合わせたハイブリッドアプローチ。
-   一定時間ごとにバックグラウンドで静的ページを再生成する(`stale-while-revalidate`)。
-   **メリット**: ビルド時間の大幅な短縮、パフォーマンスとコンテンツ鮮度の両立。
-   **デメリット**: 一時的に古いコンテンツが表示される可能性、ホスティング環境への依存。
-   大規模なブログ、ニュースサイト、ECサイトなど、ページ数が多く、コンテンツがある程度の頻度で更新されるサイトに最適。

ここまでで、Webサイトの主要なレンダリング戦略であるCSR, SSR, SSG, ISRを学びました。次のカラムでは、これらの概念をさらに進化させた、React 18とNext.js App Routerがもたらす新しいアーキテクチャについて探求していきます。

---

## 参考文献

[1] Next.js. (n.d.). *Incremental Static Regeneration*. Retrieved from https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration

[2] Vercel. (n.d.). *Incremental Static Regeneration (ISR)*. Retrieved from https://vercel.com/docs/getting-started-with-vercel/concepts/rendering#incremental-static-regeneration-isr
