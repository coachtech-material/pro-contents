# 8-2-2: ビジネスロジックの分離

## 🎯 このセクションで学ぶこと

- UIロジックとビジネスロジックの違いを理解する
- コンポーネントが肥大化する問題（Fat Component）とそのデメリットを認識する
- カスタムフックを使って、コンポーネントからビジネスロジックを効果的に分離する方法を学ぶ
- ビジネスロジックを分離することによる、テスト容易性やメンテナンス性向上のメリットを理解する

## 導入

前のセクションでカスタムフックの基本的な作成方法を学びました。カスタムフックは単にコードの重複を減らすだけでなく、Reactアプリケーションの設計をクリーンにし、メンテナンス性を劇的に向上させるための強力な設計パターンです。

その最も重要な役割の一つが、**ビジネスロジックの分離**です。コンポーネントが成長するにつれて、UIを描画するためのロジックと、アプリケーションの核となるビジネスロジックが混在し、コンポーネントが肥大化しがちです。このような「Fat Component」は、可読性が低く、テストが困難で、バグの温床となります。

このセクションでは、UIロジックとビジネスロジックを明確に区別し、カスタムフックを使って後者をコンポーネントから綺麗に分離する方法を学びます。

## 詳細解説

### UIロジック vs ビジネスロジック

まず、2つのロジックの違いを明確にしましょう。

-   **UIロジック (Presentation Logic)**
    -   UIがどのように見えるか、どのように動作するかに関するロジックです。
    -   例: ローディングスピナーの表示/非表示、モーダルウィンドウの開閉、入力値に応じたエラーメッセージの表示、アニメーションなど。
    -   これらは**コンポーネントが責任を持つべき**ロジックです。

-   **ビジネスロジック (Business Logic / Domain Logic)**
    -   アプリケーションが「何をするか」という本質的なルールやデータ処理に関するロジックです。
    -   例: APIサーバーとのデータ通信、取得したデータの加工・フィルタリング・ソート、複雑な計算、状態管理のルールなど。
    -   これらは**コンポーネントから分離すべき**ロジックです。

### 悪い例: ロジックが混在したコンポーネント

ユーザーリストを取得して表示するコンポーネントを例に考えてみましょう。すべてのロジックがコンポーネント内に存在すると、以下のようになります。

```tsx
// src/components/UserList.tsx (悪い例)
import React, { useState, useEffect } from 'react';

interface User {
  id: number;
  name: string;
}

function UserList() {
  // --- ビジネスロジック --- 
  const [users, setUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchUsers = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await fetch('https://api.example.com/users');
        if (!response.ok) {
          throw new Error('Failed to fetch users');
        }
        const data = await response.json();
        setUsers(data);
      } catch (e) {
        setError(e as Error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchUsers();
  }, []);
  // --- ビジネスロジックここまで ---

  // --- UIロジック --- 
  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <div>
      <h2>User List</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

このコンポーネントは、データの取得方法、ローディング状態の管理、エラー処理といった**ビジネスロジック**と、それらの状態に基づいて何を表示するかという**UIロジック**が密結合しています。これでは、コンポーネントの責務が多すぎます。

### 良い例: カスタムフックでビジネスロジックを分離

次に、ビジネスロジックを`useUsers`というカスタムフックに分離してみましょう。

#### 1. カスタムフックの作成

```typescript
// src/hooks/useUsers.ts
import { useState, useEffect } from 'react';

interface User {
  id: number;
  name: string;
}

export const useUsers = () => {
  // ビジネスロジックをすべてここに集約
  const [users, setUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchUsers = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await fetch('https://api.example.com/users');
        if (!response.ok) {
          throw new Error('Failed to fetch users');
        }
        const data = await response.json();
        setUsers(data);
      } catch (e) {
        setError(e as Error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchUsers();
  }, []);

  // コンポーネントが必要とするものだけを返す
  return { users, isLoading, error };
};
```

#### 2. クリーンになったコンポーネント

カスタムフックを利用する側のコンポーネントは、ビジネスロジックの詳細を知る必要がなくなり、UIの描画に専念できます。

```tsx
// src/components/UserList.tsx (良い例)
import React from 'react';
import { useUsers } from '../hooks/useUsers';

function UserList() {
  // ビジネスロジックはカスタムフックから取得
  const { users, isLoading, error } = useUsers();

  // UIロジックに専念
  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <div>
      <h2>User List</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

`UserList`コンポーネントは、もはやデータがどこから、どのようにして来るのかを知りません。ただ `useUsers` フックを呼び出し、返された `isLoading`, `error`, `users` の状態に基づいて適切なUIを描画するだけです。責務が明確に分離され、非常に見通しが良くなりました。

### 分離によるメリット

-   **テスト容易性**: `useUsers`フックはUIから独立した純粋なロジックの塊です。React Testing Libraryなどを使って、コンポーネントをレンダリングすることなく、フック単体でテストすることが容易になります。
-   **可読性・メンテナンス性**: コンポーネントはUIの構造に、フックはビジネスロジックにそれぞれ集中しているため、コードを読むべき場所が明確になります。仕様変更時も、修正箇所を特定しやすくなります。
-   **再利用性**: もし別のページで同じユーザーリストが必要になった場合、`useUsers`フックを再度呼び出すだけで済みます。ロジックをコピペする必要はありません。

## ✨ まとめ

-   コンポーネントの責務は**UIの表示**に限定し、API通信などの**ビジネスロジック**はカスタムフックに分離することが、クリーンなReactアプリケーションを設計する鍵である。
-   カスタムフックは、状態（State）とそれに付随するロジック（Effectや関数）をカプセル化し、コンポーネントから隠蔽するための最適な場所を提供する。
-   ビジネスロジックを分離することで、コンポーネントは「Fat Component」になるのを防ぎ、**テスト容易性、可読性、再利用性**が大幅に向上する。
