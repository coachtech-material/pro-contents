# 8-2-1: カスタムフックの作成方法

## 🎯 このセクションで学ぶこと

- Reactのカスタムフックが何であるかを理解する
- コンポーネント間でロジックを再利用するためにカスタムフックを作成する必要性を学ぶ
- カスタムフックを作成するための2つの主要なルールを習得する
- 簡単な `useCounter` カスタムフックを実際に作成し、コンポーネントで使用する方法を学ぶ

## 導入

React Hooks（`useState`, `useEffect`など）は、関数コンポーネントに状態管理や副作用の機能をもたらす強力なツールです。しかし、アプリケーションが複雑になるにつれて、複数のコンポーネントで同じような状態ロジック（例: データのフェッチ、フォームの入力管理、タイマーなど）を繰り返し記述することが増えてきます。

このようなロジックの重複を避け、再利用可能な形でカプセル化するための仕組みが**カスタムフック**です。カスタムフックは、Reactに組み込まれている機能ではなく、開発者が自分で作成する「`use`で始まる名前のJavaScript関数」です。この関数の中に、`useState`や`useEffect`などの基本的なフックを組み合わせることで、特定の機能に特化した独自のフックを作ることができます。

## 詳細解説

### 🔑 カスタムフックとは？

カスタムフックとは、一言で言えば**「状態を持つロジックをコンポーネントから抽出し、再利用可能にするための関数」**です。これはReactの機能というよりは、フックの設計思想に基づいた一つの規約（Convention）です。

例えば、「カウンター機能」を考えたとき、それには以下の要素が含まれます。

-   現在のカウント数を保持する`state`
-   カウントを1増やす関数
-   カウントを1減らす関数
-   カウントをリセットする関数

これらのロジックをコンポーネント内に直接書くのではなく、`useCounter`という一つの関数にまとめることで、どのコンポーネントからでも簡単にカウンター機能を呼び出して使えるようになります。

### なぜカスタムフックが必要か？

カスタムフックの主な目的は、**ロジックの再利用**と**関心の分離**です。

1.  **ロジックの再利用**: 同じようなコードをコピペすることなく、複数のコンポーネントで同じ状態管理ロジックを共有できます。これにより、コードの重複が減り、メンテナンス性が向上します。
2.  **関心の分離**: コンポーネントはUIの表示という「関心」に集中し、複雑な状態管理ロジックはカスタムフックに分離できます。これにより、コンポーネントのコードがクリーンで読みやすくなります。

### カスタムフックのルール

カスタムフックを作成するには、2つの重要なルールを守る必要があります。

1.  **名前は必ず `use` で始める**: `useCounter`, `useFetch`, `useForm` のように、関数名を `use` で始める必要があります。これにより、ReactとESLintプラグインが、その関数がフックのルール（例: トップレベルでのみ呼び出す）に従うべきものだと認識できます。
2.  **カスタムフック内では他のフックを呼び出せる**: カスタムフックの内部では、`useState`, `useEffect` などの基本的なフックや、他のカスタムフックを呼び出すことができます。これがカスタムフックが「状態を持つ」ロジックをカプセル化できる理由です。

### 実装例: `useCounter`フックの作成

それでは、シンプルなカウンター機能を持つ `useCounter` カスタムフックを作成してみましょう。

```typescript
// src/hooks/useCounter.ts
import { useState } from 'react';

// カスタムフックの戻り値の型を定義
interface UseCounterReturn {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

// カスタムフックを定義。初期値を受け取れるようにする
const useCounter = (initialValue: number = 0): UseCounterReturn => {
  // ① useStateを使って状態を管理
  const [count, setCount] = useState(initialValue);

  // ② ロジック（関数）を定義
  const increment = () => setCount(prevCount => prevCount + 1);
  const decrement = () => setCount(prevCount => prevCount - 1);
  const reset = () => setCount(initialValue);

  // ③ 必要な値と関数をオブジェクトとして返す
  return { count, increment, decrement, reset };
};

export default useCounter;
```

#### コードのポイント

-   `useCounter.ts` というように、フックは専用のファイルに切り出すのが一般的です。
-   `useState` を使って、カウンターの状態 `count` を管理しています。
-   `increment`, `decrement`, `reset` という、`count` を更新するための関数を定義しています。
-   最後に、コンポーネント側で使いたい値（`count`）と関数をオブジェクトにまとめて返却しています。配列で返すパターン（`useState`のように）も可能です。

### カスタムフックの利用

作成した `useCounter` フックをコンポーネントで使ってみましょう。使い方は `useState` などの組み込みフックと全く同じです。

```tsx
// src/components/CounterComponent.tsx
import React from 'react';
import useCounter from '../hooks/useCounter';

function CounterComponent() {
  // カスタムフックを呼び出し、必要な値と関数を取り出す
  const { count, increment, decrement, reset } = useCounter(10); // 初期値を10に設定

  return (
    <div>
      <h2>Counter</h2>
      <p>Current Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}

export default CounterComponent;
```

コンポーネントのコードが非常にシンプルになったことに注目してください。カウンターに関する複雑なロジックはすべて `useCounter` フックに隠蔽され、コンポーネントはそれを呼び出してUIを構築することに専念できています。これがカスタムフックの力です。

## ✨ まとめ

-   カスタムフックは、状態を持つロジックをコンポーネントから抽出し、再利用するためのJavaScript関数である。
-   カスタムフックの作成には2つのルールがある：**名前を`use`で始める**ことと、**内部で他のフックを呼び出せる**こと。
-   カスタムフックを使うことで、ロジックの再利用性が高まり、コンポーネントのコードがクリーンになる。
-   カスタムフックは、`useState`や`useEffect`などを組み合わせて、特定の機能（データ取得、フォーム管理など）に特化したフックを作成するために作を作成するために作した独自のフックを作成する強力なパターンである。
