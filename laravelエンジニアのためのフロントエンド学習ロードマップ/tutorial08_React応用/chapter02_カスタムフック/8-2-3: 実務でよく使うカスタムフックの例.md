# 8-2-3: 実務でよく使うカスタムフックの例

## 🎯 このセクションで学ぶこと

- 実務の現場で頻繁に作成・利用される、汎用的なカスタムフックのパターンを学ぶ
- API通信をカプセル化する `useFetch` フックの実装例を理解する
- ブラウザのLocalStorageとStateを同期させる `useLocalStorage` フックの仕組みを学ぶ
- 頻繁なイベント発火を制御する `useDebounce` フックの有用性を知る

## 導入

カスタムフックは、特定のアプリケーションのドメインロジック（例: `useUsers`, `useProducts`）を分離するためだけでなく、より汎用的で、様々なプロジェクトで再利用可能なロジックをカプセル化するためにも非常に強力です。

コミュニティには `react-use` や `ahooks` といった、便利なカスタムフックを集めたライブラリも存在し、多くの開発者がその恩恵を受けています。これらのライブラリが提供するフックは、実務で頻出する課題を解決するために作られたものばかりです。

このセクションでは、そのような「車輪の再発明」を避けつつも、カスタムフックの設計思想を深く理解するために、実務でよく使われる代表的なカスタムフックの例をいくつか見ていきましょう。

## 詳細解説

### 1. `useFetch`: APIデータ取得の汎用フック

前のセクションで作成した `useUsers` はユーザー取得に特化していましたが、これをより汎用的にし、任意のURLからデータを取得できるようにしたのが `useFetch` です。ジェネリクスを使うことで、取得するデータの型を柔軟に指定できるのがポイントです。

```typescript
// src/hooks/useFetch.ts
import { useState, useEffect } from 'react';

interface FetchState<T> {
  data: T | null;
  isLoading: boolean;
  error: Error | null;
}

export const useFetch = <T,>(url: string): FetchState<T> => {
  const [state, setState] = useState<FetchState<T>>({
    data: null,
    isLoading: true,
    error: null,
  });

  useEffect(() => {
    if (!url) return;

    const fetchData = async () => {
      setState(prevState => ({ ...prevState, isLoading: true }));
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: T = await response.json();
        setState({ data, isLoading: false, error: null });
      } catch (e) {
        setState({ data: null, isLoading: false, error: e as Error });
      }
    };

    fetchData();
  }, [url]); // URLが変更されたら再フェッチする

  return state;
};
```

**使い方:**

```tsx
interface Post { id: number; title: string; }

function PostDetails({ postId }: { postId: number }) {
  const { data: post, isLoading, error } = useFetch<Post>(
    `https://api.example.com/posts/${postId}`
  );

  if (isLoading) return <p>Loading post...</p>;
  if (error) return <p>Error: {error.message}</p>;
  if (!post) return null;

  return <h1>{post.title}</h1>;
}
```

### 2. `useLocalStorage`: LocalStorageとの同期

ユーザーの設定（例: ダークモードのON/OFF）などをブラウザのLocalStorageに保存し、ページをリロードしてもその状態が維持されるようにしたいケースはよくあります。`useLocalStorage` は、`useState` と同じインターフェースを提供しつつ、値の読み書きを自動的にLocalStorageと同期してくれます。

```typescript
// src/hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

export const useLocalStorage = <T,>(key: string, initialValue: T): [T, (value: T) => void] => {
  // 1. 初期値はLocalStorageから取得するか、なければ引数の初期値を使う
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // 2. storedValueが変更されるたびにLocalStorageを更新する
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(storedValue));
    } catch (error) {
      console.error(error);
    }
  }, [key, storedValue]);

  return [storedValue, setStoredValue];
};
```

**使い方:**

```tsx
function ThemeSwitcher() {
  // useStateと同じように使える！
  const [theme, setTheme] = useLocalStorage<
'light' | 'dark'>(
'theme', 'light');

  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  return (
    <div className={theme}>
      <p>Current theme: {theme}</p>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}
```

### 3. `useDebounce`: 入力イベントの間引き

検索ボックスなどで、ユーザーがキーを入力するたびにAPIリクエストを送ると、サーバーに過剰な負荷がかかります。`useDebounce` は、値の変更を一定時間（例: 500ms）遅延させ、その間に新しい値が来なければ、最後の値だけを返すフックです。これにより、ユーザーが入力を終えたタイミングで一度だけAPIを叩く、といった最適化が可能になります。

```typescript
// src/hooks/useDebounce.ts
import { useState, useEffect } from 'react';

export const useDebounce = <T,>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // valueが変更された後、delayミリ秒後に実行されるタイマーをセット
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // 次のeffectが実行される前（またはアンマウント時）にタイマーをクリア
    // これにより、delayの間にvalueが変更されたらタイマーはリセットされる
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};
```

**使い方:**

```tsx
function SearchInput() {
  const [searchTerm, setSearchTerm] = useState('');
  // 500ms遅延させた値を取得
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  // このeffectは、ユーザーの入力が500ms止まった時だけ実行される
  useEffect(() => {
    if (debouncedSearchTerm) {
      // ここでAPIを叩く
      console.log(`Searching for ${debouncedSearchTerm}...`);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      type="text"
      placeholder="Search..."
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  );
}
```

## ✨ まとめ

-   カスタムフックは、アプリケーション固有のロジックだけでなく、**汎用的なロジック**をカプセル化するためにも非常に有効である。
-   `useFetch` は、API通信の状態（データ、ローディング、エラー）を管理するロジックを共通化する。
-   `useLocalStorage` は、`useState`ライクなインターフェースで、状態をブラウザのLocalStorageと同期させる。
-   `useDebounce` は、頻繁に更新される値を「間引く」ことで、不要な処理（特にAPIリクエスト）の実行を防ぎ、パフォーマンスを向上させる。
-   これらのパターンを理解することで、より複雑な課題に対応できるカスタムフックを設計・実装する力が身に実装する応用力が身につく。
