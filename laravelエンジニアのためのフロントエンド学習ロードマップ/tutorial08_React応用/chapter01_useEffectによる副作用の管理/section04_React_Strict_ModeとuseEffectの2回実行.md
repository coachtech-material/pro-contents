# Tutorial 8: React応用

## Chapter 1: `useEffect`による副作用の管理

### Section 4: React Strict Modeと`useEffect`の2回実行

🎯 **このセクションで学ぶこと**

-   Reactの**Strict Mode**の目的と役割を理解する。
-   開発環境において、**`useEffect`が意図的に2回実行される**挙動を理解し、それがバグではないことを認識する。
-   `useEffect`が2回実行されても問題が起きない、**回復力のある副作用**を書くためのクリーンアップ関数の重要性を再認識する。
-   APIリクエストが2回送信される問題への具体的な対処法として、**リクエストのキャンセル**を実装できるようになる。

--- 

### イントロダクション：「APIが2回叩かれる！」パニック

React開発を始めると、多くの初学者が同じ現象に遭遇し、混乱します。

「`useEffect`を使ってAPIを`fetch`するように書いた。依存配列は`[]`にしたのに、なぜか**開発サーバーで実行するとAPIリクエストが2回飛んでしまう！** バグだ！」

これは、Reactのバグではありません。あなたのコードを将来の問題から守るための、**React Strict Modeによる親切な（しかし少しお節介な）お助け機能**なのです。

このセクションでは、この謎の2回実行の正体と、それ正しく付き合う方法を学びます。これを理解することで、あなたはReact初学者から一歩抜け出すことができます。

--- 

### ⚙️ React Strict Modeとは？

**Strict Mode**は、アプリケーションの潜在的な問題を検出するための開発用のツールです。本番環境のビルドには影響を与えず、開発中にのみ追加のチェックや警告を行います。

`src/main.tsx`（Viteの場合）を見ると、あなたの`App`コンポーネントが`<React.StrictMode>`で囲まれているのがわかります。

```tsx
// src/main.tsx
ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

Strict Modeは、安全でないライフサイクルや古いAPIの使用など、様々なことを警告してくれますが、`useEffect`に関連する最も重要な挙動が、**副作用の健全性をチェックするための意図的な2回実行**です。

--- 

### 🚀 なぜ`useEffect`が2回実行されるのか？

開発環境でStrict Modeが有効になっていると、Reactはコンポーネントの初回マウント時に、以下の動作を意図的に行います。

1.  コンポーネントをマウントする。
2.  **副作用関数を実行する。**
3.  **クリーンアップ関数を実行する。**
4.  コンポーネントを（裏側で）アンマウントする。
5.  コンポーネントを再度マウントする。
6.  **もう一度、副作用関数を実行する。**

つまり、「**マウント → 副作用 → クリーンアップ → 再マウント → 副作用**」という流れを強制的にシミュレーションしているのです。

なぜこんなことをするのでしょうか？

これは、あなたの書いた**副作用が、クリーンアップ処理を正しく実装しているか**をテストするためです。もしあなたの副作用が、クリーンアップされずに「やりっぱなし」になっている場合、この2回実行によって問題が顕在化しやすくなります（例: イベントリスナーが二重に登録される、など）。

逆に言えば、**クリーンアップが正しく実装されていれば、この2回実行は何の問題も引き起こさないはず**、というのがReactの設計思想です。これにより、将来導入されるかもしれない「状態を保持したままUIの表示・非表示を切り替える」といったReactの新機能に対しても、あなたのコンポーネントは耐性を持つことができます。

**重要なポイント:** この2回実行は**開発環境 (`npm run dev`) でのみ**発生します。本番環境用のビルド (`npm run build`) では、`useEffect`は通常通り1回しか実行されません。

--- 

### 🔒 APIリクエストの2回実行問題と対策

タイマーやイベントリスナーは、クリーンアップ関数で処理をキャンセルすれば2回実行されても問題ありません。しかし、サーバーへのPOSTリクエストや、分析データの送信のような副作用は、2回実行されると困ります。

GETリクエストの場合も、無駄なリクエストは避けたいですし、何より「なぜ2回？」と混乱するのは精神衛生上よくありません。

この問題への最もクリーンな対処法は、**`useEffect`のクリーンアップ関数で、進行中のAPIリクエストをキャンセルする**ことです。

`fetch` APIは、`AbortController`という仕組みを使ってリクエストのキャンセルをサポートしています。

**例：`fetch`リクエストをクリーンアップでキャンセルする**

```tsx
import { useEffect, useState } from "react";

type User = { id: number; name: string };

function UserProfile({ userId }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // 1. AbortControllerのインスタンスを作成
    const controller = new AbortController();

    const fetchData = async () => {
      try {
        const response = await fetch(`https://api.example.com/users/${userId}`, {
          // 2. fetchのオプションにsignalを渡す
          signal: controller.signal,
        });
        const data = await response.json();
        setUser(data);
      } catch (error) {
        // 3. リクエストがキャンセルされると、AbortErrorという名前のエラーが発生する
        if (error.name === "AbortError") {
          console.log("Fetch aborted");
        } else {
          console.error("Fetch error:", error);
        }
      }
    };

    fetchData();

    // 4. クリーンアップ関数でリクエストをキャンセルする
    return () => {
      controller.abort();
    };
  }, [userId]);

  // ...
}
```

**動作の流れ:**
1.  最初の副作用が実行され、`fetch`が開始される。
2.  Strict Modeが即座にクリーンアップを要求する。
3.  クリーンアップ関数が呼ばれ、`controller.abort()`が実行される。これにより、進行中の`fetch`リクエストはキャンセルされる。
4.  `fetch`は`AbortError`を`catch`ブロックで捕捉し、Stateの更新は行われない。
5.  2回目の副作用が実行され、新しい`fetch`リクエストが開始される。こちらはキャンセルされないため、正常に完了し、Stateが更新される。

結果として、**実質的にAPIリクエストは1回だけ成功する**ことになり、無駄なState更新や二重のデータ登録を防ぐことができます。

--- 

✨ **まとめ**

-   **React Strict Mode**は、開発中に潜在的な問題を見つけるためのツールである。
-   開発環境では、Strict Modeによって`useEffect`は「**副作用 → クリーンアップ → 副作用**」と意図的に2回実行される。
-   これは、副作用のクリーンアップ処理が正しく実装されているかをテストするためであり、バグではない。
-   この挙動は**開発環境でのみ**発生し、本番環境では1回しか実行されない。
-   APIリクエストが2回実行される問題は、`useEffect`のクリーンアップ関数で**リクエストをキャンセルする**ことで、クリーンかつ安全に対処できる。

📝 **学習のポイント**

-   [ ] もしあなたのプロジェクトから`<React.StrictMode>`を削除したら、`useEffect`の2回実行は起こらなくなります。しかし、それはなぜ推奨されないのでしょうか？ Strict Modeが提供してくれる「未来への備え」について考えてみましょう。
-   [ ] `axios`という人気のHTTPクライアントライブラリにも、リクエストをキャンセルする仕組みがあります。どのように実装できるか、公式ドキュメントを調べてみましょう。
-   [ ] この「マウント→アンマウント→再マウント」という挙動は、将来的にReactがどのような機能を実現するために役立つ可能性があるでしょうか？（ヒント: オフスクリーンになったUIの状態を保持する、など）
