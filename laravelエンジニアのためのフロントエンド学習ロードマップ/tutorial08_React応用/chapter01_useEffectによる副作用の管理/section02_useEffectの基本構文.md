# Tutorial 8: React応用

## Chapter 1: `useEffect`による副作用の管理

### Section 2: `useEffect`の基本構文

🎯 **このセクションで学ぶこと**

-   `useEffect`フックの基本的な構文を理解する。
-   副作用を実行するタイミングを制御するための**依存配列 (Dependency Array)** の役割を理解する。
-   依存配列の3つの主要なパターン（指定しない、空配列、値を含む配列）の違いを説明できるようになる。

--- 

### イントロダクション：副作用をいつ実行するか？

`useEffect`は、副作用をレンダリングから分離するためのフックですが、その真価は「**副作用を実行するタイミングを細かく制御できる**」点にあります。

-   コンポーネントが最初に表示された**ときだけ**実行したい（例: APIから初期データを取得）
-   特定のStateやPropsが変更された**ときだけ**実行したい（例: 検索クエリが変わったらAPIを再検索）
-   コンポーネントが再レンダリングされる**たびに**実行したい（あまり使わない）

このタイミングの制御を担うのが、`useEffect`の第二引数である**依存配列 (Dependency Array)** です。

--- 

### ⚙️ `useEffect`の基本構文

`useEffect`は、第一引数に**副作用関数**、第二引数に**依存配列**を取ります。

```tsx
import { useEffect } from 'react';

useEffect(
  // 1. 副作用関数：ここに実行したい副作用処理を書く
  () => {
    // 例：API通信、DOM操作、タイマー設定など
    console.log("副作用が実行されました");
  },
  // 2. 依存配列：副作用関数が「何に依存しているか」をReactに伝える
  [dependency1, dependency2, ...]
);
```

**動作の基本ルール:**
Reactは、コンポーネントのレンダリングが完了した後、**依存配列の中の値が前回のレンダリング時と変更されているか**をチェックします。もし変更があれば、第一引数の副作用関数を実行します。

--- 

### 🚀 依存配列の3つのパターン

依存配列の指定方法によって、副作用の実行タイミングは大きく3つのパターンに分かれます。これは`useEffect`を使いこなす上で最も重要な知識です。

#### パターン1：依存配列を省略する

```tsx
useEffect(() => {
  console.log("毎回のレンダリング後に実行");
}); // 依存配列を省略
```

-   **実行タイミング:** コンポーネントが**再レンダリングされるたびに**、副作用関数が実行されます。
-   **主な用途:** このパターンは、意図しない無限ループ（副作用内でStateを更新し、それが再レンダリングを引き起こし、また副作用が…）を引き起こしやすいため、**ほとんど使いません**。使う場面は非常に限定的です。

#### パターン2：空の依存配列 `[]` を指定する

```tsx
useEffect(() => {
  console.log("初回レンダリング後に一度だけ実行");
}, []); // 空の配列
```

-   **実行タイミング:** コンポーネントが最初に画面にマウント（表示）された後、**一度だけ**副作用関数が実行されます。
-   **主な用途:** これが最もよく使われるパターンの一つです。
    -   APIから初期データを取得する
    -   `window`にイベントリスナーを設定する
    -   タイマーを開始する

#### パターン3：依存配列に値 `[dep1, dep2]` を指定する

```tsx
const [count, setCount] = useState(0);
const [name, setName] = useState("Taro");

useEffect(() => {
  console.log(`countが変更されました: ${count}`);
}, [count]); // countに依存

useEffect(() => {
  console.log("countかnameが変更されました");
}, [count, name]); // countとnameに依存
```

-   **実行タイミング:**
    1.  初回レンダリング後に一度実行される。
    2.  その後、依存配列に含まれる**いずれかの値が**前回のレンダリング時と変更された場合にのみ、再レンダリング後に副作用関数が実行される。
-   **主な用途:**
    -   特定のPropsやStateの変更をトリガーとして、副作用を実行したい場合。
    -   ユーザーIDが変わったら、新しいユーザーの情報をAPIで取得する。
    -   検索クエリ（State）が変わったら、検索APIを叩き直す。
    -   Propsで渡された`isOpen`が`true`に変わったら、モーダルウィンドウを表示するアニメーションを開始する。

--- 

### 🔒 依存配列のルール

**ルール:** **副作用関数の中で使っている全てのリアクティブな値（Props, State, およびそれらから計算される変数）は、必ず依存配列に含めなければなりません。**

**❌ やってはいけないこと（依存配列の嘘）:**
```tsx
function Counter({ step }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 副作用関数の中で`step`を使っているのに…
    const intervalId = setInterval(() => {
      setCount(c => c + step);
    }, 1000);
    return () => clearInterval(intervalId);
  }, []); // …依存配列に`step`が含まれていない！
}
```

このコードでは、`step`というPropsが変更されても、`useEffect`は再実行されません。そのため、タイマーは古い`step`の値を参照し続け、意図しない挙動になります。

**⭕ 正しい方法:**
```tsx
useEffect(() => {
  // ...
}, [step]); // 正しく`step`を依存配列に含める
```

幸い、ESLintの`react-hooks/exhaustive-deps`というルールがデフォルトで有効になっており、依存配列に漏れがあると警告を出してくれます。この警告は**絶対に無視せず**、指示に従って修正してください。

--- 

✨ **まとめ**

-   `useEffect`の第二引数、**依存配列**は、副作用を実行するタイミングを制御する。
-   **依存配列を省略**: 毎回のレンダリング後（非推奨）。
-   **空の依存配列 `[]`**: 初回レンダリング後に一度だけ。
-   **依存配列に値 `[dep]`**: 初回と、`dep`が変更された後のレンダリング後。
-   **ルール**: 副作用関数内で使っているPropsやStateは、**すべて**依存配列に含める必要がある。

📝 **学習のポイント**

-   [ ] ユーザーのプロフィールを表示するコンポーネントを考えます。`userId`というPropsを受け取り、そのIDを使ってAPIからユーザー情報を取得する場合、`useEffect`の依存配列はどうあるべきですか？
-   [ ] 画面の横幅を検知してStateに保存するコンポーネントを考えます。`window`の`resize`イベントを監視する必要があります。イベントリスナーの登録と解除は、それぞれ`useEffect`のどの部分で、どの依存配列パターンを使って行うべきでしょうか？
-   [ ] ESLintの`exhaustive-deps`ルールは、なぜこれほどまでに重要なのでしょうか？ もしこのルールがなかったら、どのようなバグが生まれやすくなるか想像してみましょう。
