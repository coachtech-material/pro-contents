# Tutorial 8: React応用

## Chapter 1: `useEffect`による副作用の管理

### Section 3: クリーンアップ関数

🎯 **このセクションで学ぶこと**

-   副作用の「後片付け」である**クリーンアップ**の必要性を理解する。
-   `useEffect`の副作用関数から**クリーンアップ関数**を返す方法を習得する。
-   クリーンアップ関数が実行される2つの主要なタイミングを説明できるようになる。

--- 

### イントロダクション：副作用の「やりっぱなし」は危険

`useEffect`で副作用を開始するのは簡単ですが、場合によっては、その副作用を**終了**または**キャンセル**する必要があります。これを怠ると、メモリリークや意図しない挙動の原因となります。

例えば、
-   `setInterval`でタイマーを開始したら、コンポーネントが不要になったときにタイマーを停止しないと、永遠に動き続けてしまう。
-   `window`にイベントリスナーを追加したら、コンポーネントが不要になったときに解除しないと、メモリリークに繋がる。
-   APIリクエストを送信した後、レスポンスが返ってくる前にコンポーネントがアンマウントされたら、そのレスポンスを使ってStateを更新しようとしてエラーになる。

このような「やりっぱなし」の副作用を片付けるための仕組みが、`useEffect`の**クリーンアップ関数**です。

--- 

### ⚙️ クリーンアップ関数の構文

クリーンアップ処理を登録するには、`useEffect`の第一引数である副作用関数から、**関数を返します**。この返された関数がクリーンアップ関数となります。

```tsx
useEffect(() => {
  // 1. 副作用の処理（例：イベントリスナーの登録）
  console.log("副作用が開始されました");
  window.addEventListener("scroll", handleScroll);

  // 2. クリーンアップ関数を返す
  return () => {
    // 3. 副作用の片付け処理（例：イベントリスナーの解除）
    console.log("クリーンアップが実行されました");
    window.removeEventListener("scroll", handleScroll);
  };
}, []); // 依存配列
```

--- 

### 🚀 クリーンアップ関数が実行されるタイミング

クリーンアップ関数は、主に2つのタイミングで実行されます。

#### タイミング1：コンポーネントがアンマウントされるとき

コンポーネントが画面から消える（アンマウントされる）直前に、最後の後片付けとして実行されます。

**例：タイマーのクリーンアップ**

```tsx
function Timer() {
  const [time, setTime] = useState(0);

  useEffect(() => {
    // 1秒ごとにtimeをインクリメントするタイマーを開始
    const intervalId = setInterval(() => {
      setTime(t => t + 1);
    }, 1000);

    // コンポーネントがアンマウントされるときにタイマーを停止
    return () => {
      clearInterval(intervalId);
    };
  }, []); // 初回レンダリング時に一度だけ実行

  return <div>Time: {time}</div>;
}
```

もしクリーンアップがないと、この`Timer`コンポーネントが画面から消えても、`setInterval`はバックグラウンドで動き続け、メモリを消費し続けます。

#### タイミング2：次の副作用が実行される直前

依存配列に値が指定されている場合、その値が変更されて**次の副作用が実行される直前**に、前回の副作用に対するクリーンアップが実行されます。

**「次の副作用の前に、前回の副作用を片付ける」**というイメージです。

**例：特定のユーザーIDを購読する**

```tsx
function UserProfile({ userId }) {
  useEffect(() => {
    // 1. 新しいuserIdでチャットサーバーに接続
    const connection = connectToChat(userId);

    // 2. userIdが変更されたら、次の接続の前に古い接続を切断する
    return () => {
      disconnectFromChat(connection);
    };
  }, [userId]); // userIdに依存

  return <h1>Welcome, User {userId}!</h1>;
}
```

このコンポーネントの`userId`が`1`から`2`に変わったときの流れは以下のようになります。

1.  `userId`が`2`に変わり、コンポーネントが再レンダリングされる。
2.  Reactは`useEffect`の依存配列`[userId]`が変更されたことを検知する。
3.  **（クリーンアップ）** 前回の`userId=1`の副作用に対するクリーンアップ関数（`disconnectFromChat(connectionForUser1)`）を実行する。
4.  **（次の副作用）** 今回の`userId=2`の副作用関数（`connectToChat(2)`）を実行する。

これにより、常に一つの`userId`に対する接続だけがアクティブな状態に保たれます。

--- 

### 🔒 クリーンアップが必要ない場合

すべての副作用にクリーンアップが必要なわけではありません。

例えば、一度きりのAPIリクエスト（`fetch`）のように、後片付けが不要な副作用もあります。その場合は、副作用関数から何も返す必要はありません。

```tsx
useEffect(() => {
  // fetchは完了したら自動的に終了するので、クリーンアップは不要
  fetch("/api/data").then(...);
}, []);
```

ただし、この場合でも、レスポンスが返る前にコンポーネントがアンマウントされる可能性を考慮した、より高度なクリーンアップ（リクエストのキャンセル）が存在します。これは次のセクションで学びます。

--- 

✨ **まとめ**

-   副作用の後片付けを行うために、`useEffect`の副作用関数から**クリーンアップ関数**を返すことができる。
-   クリーンアップ関数は、以下のタイミングで実行される。
    1.  **コンポーネントがアンマウントされるとき**
    2.  **依存配列の値が変わり、次の副作用が実行される直前**
-   タイマーの停止、イベントリスナーの解除、ネットワーク接続の切断など、継続的な副作用にはクリーンアップが不可欠である。

📝 **学習のポイント**

-   [ ] `useEffect`のクリーンアップは、PHPの`__destruct`やJavaの`finally`ブロックと似ている点、違う点は何でしょうか？
-   [ ] 依存配列が空`[]`の場合、クリーンアップ関数が実行されるのはいつですか？
-   [ ] 依存配列を省略した場合、クリーンアップ関数はいつ実行されるでしょうか？ このパターンの挙動を想像してみましょう。
