# CoachTechフロントエンド教材執筆ガイドライン（完全版 v7）

## 🎯 執筆で気をつけるポイント（Overview）

### 1. 分量の確保【v10で大幅強化】
- **最低文字数**: 1セクションあたり最低**4,000文字**を厳守する。重たい学習内容の場合は、上限を設けず、初学者が理解できるまで詳細な説明を行う。
- **対象読者**: プログラミング未経験・ITリテラシーが高くない学習者を想定し、説明の丁寧さ・わかりやすさを最優先にする。
- **内容の具体性**: 内容が薄くならないよう、具体例、実践演習、初学者でもわかりやすい概念に対する丁寧な説明とコードリーディングを徹底する。

### 2. 構成の統一
各セクションは以下の構成で統一する。

1.  **🖼️ 完成形のイメージ**: このセクションやハンズオンで何を作るのか、完成形のイメージ（スクリーンショット等）を提示する。
2.  **🎯 このセクションで学ぶこと**: 学習目標を「〜ができるようになる」「〜を説明できる」といった具体的な行動目標として箇条書きで2〜3項目明示する。
3.  **導入**: なぜこの技術が必要か、実務での具体例を挙げて説明する。
4.  **概念の説明**: 比喩を交えつつ、技術の概要を分かりやすく解説する。
5.  **詳細解説**: コマンドやコードの使い方、オプション、注意点を詳細に説明する。
6.  **💡 TIP**: 補足情報、よくある間違い、ベストプラクティスを提示する。
7.  **🏃 実践**: ステップバイステップのハンズオン形式で、学習者が実際に手を動かせるようにする。
8.  **コードリーディング**: 実践パートで使ったコードや実行結果を1行ずつ丁寧に解説する。
9.  **✨ まとめ**: セクションの要点を3〜5項目で箇条書きで整理する。
10. **📝 学習のポイント**: 学習者がセクションの理解度を自己評価できるチェックリストを3〜5項目で提供する。

### 3. 比喩の使い方
- **避けるべき比喩**: 過度に凝った比喩（例: 「魔法の杖」「秘密の呪文」）は避ける。
- **推奨される比喩**: 身近で実用的な比喩（例: 「設計図」「レシピ」「コピー機」）を自然な形で導入する。
- **導入方法**: 「比喩で理解する:」のような直接的な事前通告は避け、文章の流れの中で自然に使う。

### 4. 実践とコードリーディング
- **コード解説**: すべてのコード例には、処理の流れを1行ずつ丁寧に解説する。
- **実行結果**: 実行結果を必ず明示し、何が起きているかを説明する。
- **エラー対応**: エラーが発生する可能性がある場合は、その原因と具体的な対処法も記載する。

### 5. 初学者への配慮【v10で大幅強化】
- **専門用語の言い換え**: 専門用語は必ず初出時に「日常の言葉」で言い換える（例: 「リポジトリ」→「プロジェクトの保管庫」）。その後、専門用語を併記して慣れさせる。
- **「なぜ」の説明**: 抽象的な概念を学ぶ前に、「これができると何が嬉しいのか」を実務での具体例で示す。
- **スクリーンショットの活用**: GUI操作（VSCode、GitHub、Chrome DevToolsなど）は、クリックする場所が明確にわかるスクリーンショットを豊富に使う。（執筆時には「ここにスクリーンショットを挿入: [説明]」と明記する）
- **つまずきポイントの先回り**: 「ここでエラーが出たら、こうしてください」のように、学習者がつまずきそうなポイントを予測し、事前に解決策を提示する。
- **心理的負担の軽減**: 「今は完全に理解しなくてもOKです」のように、一度に全てを理解する必要がないことを伝え、学習者の心理的負担を減らす。
- **段階的な学習**: 「前のセクションで学んだ〇〇を使います」のように、前提知識を確認し、学習内容が積み上がっていることを意識させる。

### 6. コードリーディングの徹底
（「4. 実践とコードリーディング」と重複するが、重要なので再掲）
- すべてのコード例には、処理の流れを1行ずつ解説する。
- 実行結果を明示し、何が起きているかを説明する。
- エラーが出る場合は、その原因と対処法も記載する。

### 7. 実践重視
- 各セクションに必ず「🏃 実践」パートを設ける。
- ステップバイステップで、学習者が迷わずに手を動かせる内容にする。
- 実践後に「何ができるようになったか」を明確にし、達成感を得られるようにする。

### 8. 表とコードブロックの活用
- **表形式**: 複雑な情報（メリット/デメリットの比較、コマンドオプション一覧など）は、積極的に表形式で整理する。
- **コードブロック**: コマンド、ソースコード、設定ファイルの内容、実行結果は、必ずシンタックスハイライト付きのコードブロックで記述する。

### 9. 絵文字の効果的な活用
以下の絵文字を統一的に使用し、視覚的な分かりやすさを高める。

-   **🎯**: 学習目標、次のステップ
-   **✨**: まとめ
-   **💡**: TIP、補足情報
-   **⚠️**: 注意事項
-   **🏃**: 実践
-   **📝**: 学習のポイント
-   **🔑**: 重要な概念
-   **⚙️**: ツール、コマンド
-   **🧠**: 先輩エンジニアの思考プロセス

### 10. 重複の削減
- 同じ概念を複数の章で不必要に繰り返さない。
- 前のセクションで説明した内容は、「Tutorial Xで学んだ通り…」のように簡潔に参照する。
- 演習は可能な限り統合し、一つのアプリケーションを一気通貫で開発するようなストーリー性を持たせる。（ただし、特定の概念をドリル形式で反復練習させるための問題はその限りではない）

---

## 🚀 現場直結スキル（8つの重点項目）【FE特化版】

### 1. デバッグ力の強化（DevToolsの歩き方）
**カリキュラムへの反映場所**: Tutorial 7 (JS応用), Tutorial 15 (パフォーマンス最適化)

Chrome DevToolsの読み方を徹底的に習得することで、フロントエンド開発における問題解決能力を大幅に向上させる。`Console`でのエラー読解、`Network`タブでのAPI通信確認、`Components`タブ（React DevTools）でのProps/State追跡方法を学ぶ。よくあるエラー集として、`Cannot read properties of undefined`（データ取得前のレンダリング）、`Hydration failed`（SSRとCSRの不一致）、`Too many re-renders`（useEffectの無限ループ）などを先回りして解説する。

### 2. 早期リターン (Early Return) の徹底
**カリキュラムへの反映場所**: Tutorial 7 (JS応用), Tutorial 10 (React基礎)

「ネストは悪」という思想を植え付け、読みやすく保守性の高いコードを書く習慣を身につける。`if (isLoading) { return <Spinner />; }`のようなコンポーネントの早期リターン、バリデーションや権限チェックをHooksや関数の冒頭に集める手法を学ぶ。

### 3. APIにおける「異常系」のハンドリング
**カリキュラムへの反映場所**: Tutorial 11 (React応用), Tutorial 16 (フルスタック開発)

`TanStack Query`の`isError`, `error`を使ったUI分岐、`ErrorBoundary`と`Suspense`を使った宣言的なエラー・ローディング処理を習得する。特に、適切なHTTPステータスコード（200、201、404、422）に応じたフロントエンドの挙動を徹底的に解説し、実務で直面する各種エラーシナリオに対応できる力を養う。

### 4. ディレクトリ構成戦略の理解
**カリキュラムへの反映場所**: Tutorial 11 (React応用), Tutorial 12 (Next.jsセットアップ)

`feature-based`（機能ごと）と`layer-based`（役割ごと）のディレクトリ構成の違いを理解し、プロジェクトの規模に応じた最適な構成を選択できるようになる。コンポーネント、Hooks、API通信、型定義などのファイルを適切に配置し、「どこに何があるか」が予測可能な構成の重要性を学ぶ。

### 5. 変数名・関数名の「具体性」への執着（命名力）
**カリキュラムへの反映場所**: Tutorial 6 (JS基礎), Tutorial 14 (チーム開発)

**NG**: `$data` → **OK**: `$activeUsers`、**NG**: `$flag` → **OK**: `$isPublished`、**NG**: `get()` → **OK**: `fetchLatestTasks()`といった具体例を通じて、「推測させるな、説明しろ」という命名哲学を徹底する。変数名や関数名から、その役割や意図が明確に伝わるコードを書く習慣を身につける。

### 6. コンポーネントの「粒度」と「責務」
**カリキュラムへの反映場所**: Tutorial 11 (React応用), Tutorial 14 (チーム開発)

「Atomic Design」の思想を理解し、再利用可能なコンポーネントを設計する。「Presentational Component」と「Container Component」の分離、1つのコンポーネントには1つの責務しか持たせない（Single Responsibility Principle）といった設計パターンを学ぶ。

### 7. モダンな配列操作の徹底（イミュータビリティ）
**カリキュラムへの反映場所**: Tutorial 7 (JS応用)

`for`ループではなく、`map`, `filter`, `reduce`を使いこなす。「元の配列を直接変更しない」というイミュータブルな操作の重要性をReactのState更新と関連付けて学ぶ。スプレッド構文（`...`）を使った安全な配列・オブジェクトのコピーと更新を習得する。

### 8. 「環境変数 (.env)」の厳格な管理
**カリキュラムへの反映場所**: Tutorial 13 (Next.js実践), Tutorial 16 (フルスタック開発)

「機密情報は絶対にコードに書くな」というセキュリティ意識を徹底する。`NEXT_PUBLIC_`の有無による環境変数の公開・非公開の違いを理解し、APIキーやDB接続情報などを`.env.local`で管理し、`process.env`経由で安全に読み込む方法を学ぶ。

---

## 🔑 重要な設計思想【FE特化版】

### 1. 「構造とデザイン」から「状態とUI」へ
HTML/CSSはUIを表現するための手段と位置づけ、「状態（State）がどのようにUIに反映されるか」という宣言的UIのデータフローに学習の焦点を当てる。

### 2. 「書く」から「使いこなす」へ
CSSはTailwind CSS、状態管理はTanStack QueryやZustandといったエコシステムを積極的に活用し、車輪の再発明を避けて生産性を高める方法を学ぶ。

### 3. 「フロントエンド完結」から「API連携前提」へ
フロントエンドは常にバックエンドと連携することを前提とする。`msw`（Mock Service Worker）などを用いてAPIのモックを作成し、実践的なデータ取得・更新処理を学ぶ。

### 4. 「個別課題」から「イシュー駆動」へ
すべての実装をGit Flow × イシュー駆動で行い、実務フローを体得する。

### 5. 「レンダリングで苦労させて概念を理解させる」→「Reactで楽をさせて便利さを実感させる」
ブラウザのレンダリングパイプラインや仮想DOMの仕組みを先に学習し、Reactでの実装時に「魔法」ではなく「仕組み」として理解できるようにする。

### 6. 「難しい理論は知らないけれど、エラーを自分で解決でき、チーム開発で迷惑をかけないコードが書ける」
JavaScriptのOOP（クラス）はReactのクラスコンポーネントを理解する最低限に留め、関数コンポーネントとHooks中心のモダンな開発スタイルに集中する。

### 7. 「チーム開発の重要性は、実践を通じて理解する」
Storybookやコンポーネントテストを導入し、「動くもの」を作れるようになった直後に「じゃあこれをチームで保守・改善するには？」という流れで品質保証の概念を導入する。

### 8. 「型（Type）への意識を早期に植え付ける」
現代のフロントエンド開発ではTypeScriptが標準であるため、JavaScriptを学んだ直後にTypeScriptを導入し、以降のカリキュラムは全て型を意識したコードで進める。

### 9. 「コンポーネントはUIの部品である」
Storybookを活用し、コンポーネントを個別のカタログとして管理する手法を学ぶ。これにより、再利用性、テスト容易性、チーム内での認識共有の重要性を体感する。

### 10. 「ディレクトリ構成とコンポーネント設計は一体で学ぶ」
コンポーネントの粒度（Atomic Design）と、それを格納するディレクトリ構成（feature-based）はセットで学ぶことで、拡張性の高いアプリケーション設計の基礎を固める。

---

## ✍️ 全チュートリアル共通: ハンズオンセクションの執筆方針

全チュートリアル（Tutorial 1〜16）のハンズオンを含むセクションには、以下の4つの要素を必ず含めます。

### 1. Step形式への統一

| 項目 | 内容 |
| :--- | :--- |
| **形式** | 全セクションで「Step 1」「Step 2」...の形式で手順を明確化する |
| **タイトル** | 各Stepには明確なタイトルを付ける（例: 「Step 1: プロジェクトの作成」） |
| **サブステップ** | Stepの中でさらに細かい手順がある場合は「1-1」「1-2」のようにサブステップを使用する |
| **目的** | 学習者が「今どこにいるか」を常に把握できるようにする |

### 2. 先輩エンジニアの思考プロセス

| 項目 | 内容 |
| :--- | :--- |
| **配置** | 各セクション冒頭に「🧠 先輩エンジニアの思考プロセス」セクションを追加する |
| **問いかけ** | 「なぜこの順番で実装するのか」という問いかけから始める |
| **理由** | 理由を3つ程度挙げて、実装順番の意図を明確にする |
| **表形式** | 「このセクションでやること」を表形式で整理する |
| **まとめ** | 💡 ポイントで重要な考え方を一言でまとめる |

### 3. コードリーディングの充実

| 項目 | 内容 |
| :--- | :--- |
| **配置** | すべてのコードブロックの後に詳細な解説を追加する |
| **見出し** | 「コードリーディング」という見出しを付けて、1行ずつ解説する |
| **形式** | 表形式で「コード」と「説明」を対応させると分かりやすい |
| **目的** | 初学者が「なぜこう書くのか」を理解できるように丁寧に解説する |

### 4. 表形式の活用

| 項目 | 内容 |
| :--- | :--- |
| **目的** | 情報を整理して見やすくするために表を積極的に使用する |
| **用途** | 比較（メリット/デメリット）、一覧（コマンド/オプション）、対応関係（入力/出力）などに表を使う |
| **効果** | 長い文章よりも表で整理することで、学習者の理解を助ける |
| **補足** | 表の後には必ず補足説明を加える |

**適用範囲**
- Tutorial 1〜16の全チュートリアルに適用
- 特にハンズオン（実践）を含むセクションで徹底する
- 概念説明のみのセクションでも、可能な限りStep形式と表形式を活用する

### 補足: ハンズオンセクション（*_hands_on.md）の構成（v12で追加）

各チャプター末尾のハンズオンセクションには、以下の構成で「🏃 実践: 一緒に作ってみましょう！」セクションを追加します。

| 項目 | 内容 |
| :--- | :--- |
| **配置位置** | 「💡 ヒント」と「📖 模範解答」の間 |
| **文字数** | 3,000～5,000文字（詳細な解説を含む） |
| **内容構成** | **💭 実装の思考プロセス**: 実装する際の考え方を簡潔に説明（ポイントを結論として明示）<br>**📝 ステップバイステップで実装**: 各ステップごとに以下を含む<br>  - **何を考えているか**: そのステップでの思考プロセスを明示<br>  - **コマンド/コード**: 実際に実行するコマンドやコードを提示<br>  - **コマンド解説/コードリーディング**: 各行の意味を丁寧に解説<br>**✨ 完成！**: 学習者を励ますメッセージ |

---

## 📚 全16チュートリアルの詳細構成

### Tutorial 1: 開発環境とWebの基礎固め（12セクション）

**学習目標**: フロントエンド開発に必要なツールをセットアップし、Webがどのように動作しているかの基本的な仕組みを理解する。

**到達レベル**: VSCode, Git, コマンドラインの基本操作ができ、HTTPの役割を説明できる。

**推定学習時間**: 30時間

#### Chapter 1: イントロダクション（2セクション）
- **1-1-1: フロントエンドエンジニアの役割とモダンな開発フロー**
- **1-1-2: 学習を成功させるための心構えと進め方**

#### Chapter 2: Webの基本的な仕組み（4セクション）
- **2-2-1: Webの基本的な仕組み（リクエスト・レスポンス）**
- **2-2-2: HTTPプロトコルの基礎（メソッド、ステータスコード）**
- **2-2-3: APIとは何か？**
- **2-2-4: チャプターハンズオン：curlコマンドでAPIを叩いてみる**

#### Chapter 3: 開発ツールのセットアップ（3セクション）
- **3-3-1: Webブラウザ（Google Chrome）とデベロッパー・ツールの基本**
- **3-3-2: テキストエディタ（VSCode）のインストールと基本設定**
- **3-3-3: VSCodeの便利な拡張機能（Prettier, ESLintなど）**

#### Chapter 4: コマンドライン（CLI）入門（3セクション）
- **4-4-1: なぜコマンドラインが必要なのか？**
- **4-4-2: ファイルとディレクトリの基本操作（`ls`, `cd`, `pwd`, `mkdir`, `touch`）**
- **4-4-3: チャプターハンズオン：コマンドラインでプロジェクトの雛形を作成する**

---

### Tutorial 2: HTML/CSS基礎（11セクション）

**学習目標**: Webページの骨格と装飾を担当するHTMLとCSSを習得し、セマンティックで構造的なマークアップができるようになる。

**到達レベル**: HTMLでページ構造を作成し、CSSで基本的なスタイリングができる。

**推定学習時間**: 40時間

#### Chapter 1: HTML基礎（6セクション）
- **1-1: HTMLの役割と基本構造（`DOCTYPE`, `html`, `head`, `body`）**
- **1-2: 主要なHTMLタグ（見出し、段落、リスト、リンク、画像）**
- **1-3: セマンティックHTMLの重要性（`header`, `footer`, `nav`, `main`, `section`, `article`）**
- **1-4: フォームの作成（`form`, `input`, `textarea`, `button`, `label`）**
- **1-5: アクセシビリティの基本（`alt`属性、`aria-label`など）**
- **1-6: チャプターハンズオン：セマンティックなブログ記事ページを作成する**

#### Chapter 2: CSS基礎（5セクション）
- **2-1: CSSの役割と基本的な書き方（セレクタ、プロパティ、値）**
- **2-2: ボックスモデルの理解（`margin`, `padding`, `border`, `width`, `height`）**
- **2-3: 文字と背景のスタイリング（`color`, `font-size`, `background-color`）**
- **2-4: Flexboxを使ったレイアウト（`display:flex`, `justify-content`, `align-items`）**
- **2-5: チャプターハンズオン：Flexboxでヘッダーとフッターを作成する**

---

### Tutorial 3: 素のCSS特訓：レイアウトと詳細度（9セクション）

**学習目標**: CSSの根本的な仕組みを深く理解し、Tailwindなどのフレームワークに頼らずに堅牢なスタイルを書けるようになる。

**到達レベル**: 詳細度を意識したCSS設計ができ、BEMなどの命名規則を説明できる。

**推定学習時間**: 40時間

#### Chapter 1: CSSのコア概念の深掘り（4セクション）
- **1-1: 詳細度（Specificity）の計算と優先順位（ID > Class > Element）**
- **1-2: カスケーディングと継承の仕組み**
- **1-3: `!important` の使い方と避けるべき理由**
- **1-4: チャプターハンズオン：詳細度を考慮してCSSを上書きする**

#### Chapter 2: 実践的レイアウト手法（3セクション）
- **2-1: CSS Variables（カスタムプロパティ）による設計（`--color-primary`など）**
- **2-2: Grid Layoutを使った高度なレイアウト（`display:grid`, `grid-template-columns`）**
- **2-3: チャプターハンズオン：Grid Layoutでカード型レイアウトを作成する**

#### Chapter 3: CSSの命名規則と設計（2セクション）
- **3-1: BEM（Block Element Modifier）による命名規則**
- **3-2: チャプターハンズオン：BEM記法でブログサイトのレイアウトを組む**

---

### Tutorial 4: 依存関係ツールと設定ファイル詳解（10セクション）

**学習目標**: フロントエンド開発のエコシステムを支える依存関係管理ツールと、プロジェクトの挙動を定義する各種設定ファイルの役割と使い方をマスターする。

**到達レベル**: npm/yarn/pnpmを使い分け、`package.json`や`tsconfig.json`を適切に設定・編集できる。

**推定学習時間**: 30時間

#### Chapter 1: パッケージマネージャ入門（5セクション）
- **1-1: パッケージマネージャとは何か？（npm, yarn, pnpm）**
- **1-2: `package.json`の役割と主要なフィールド（`name`, `version`, `scripts`）**
- **1-3: `dependencies` vs `devDependencies`**
- **1-4: `npm install`, `npm run`などの基本コマンド**
- **1-5: チャプターハンズオン：npmを使ってプロジェクトを初期化し、ライブラリをインストールする**

#### Chapter 2: フロントエンドの設定ファイル詳解（5セクション）
- **2-1: なぜ設定ファイルが必要なのか？**
- **2-2: `tsconfig.json`の主要な設定項目（`compilerOptions`, `include`）**
- **2-3: リンターとフォーマッター（`.eslintrc.json`, `.prettierrc.json`）の役割**
- **2-4: ビルドツールの設定ファイル（`vite.config.ts`, `next.config.mjs`）の概要**
- **2-5: チャプターハンズオン：ESLintとPrettierを導入し、コード整形を自動化する**

---

### Tutorial 5: Tailwind CSS 徹底習得（9セクション）

**学習目標**: ユーティリティファーストのCSSフレームワークであるTailwind CSSを使いこなし、高速でメンテナンス性の高いUI開発を実現する。

**到達レベル**: Tailwind CSSの基本設定ができ、レスポンシブデザインを実装できる。

**推定学習時間**: 40時間

#### Chapter 1: Tailwind CSS入門（4セクション）
- **1-1: ユーティリティファーストとは何か？従来のCSS設計との違い**
- **1-2: Tailwind CSSのセットアップと基本設定**
- **1-3: 基本的なユーティリティクラス（色、余白、フォントサイズ）**
- **1-4: チャプターハンズオン：Tailwind CSSでボタンコンポーネントを作成する**

#### Chapter 2: レイアウトとレスポンシブ（4セクション）
- **2-1: FlexboxとGridをユーティリティクラスで実装する**
- **2-2: ブレークポイント（`sm`, `md`, `lg`）を使ったレスポンシブデザイン**
- **2-3: `container`クラスと最大幅の管理**
- **2-4: チャプターハンズオン：レスポンシブ対応のナビゲーションバーを作成する**

#### Chapter 3: 応用とカスタマイズ（1セクション）
- **3-1: `tailwind.config.js`によるテーマのカスタマイズ（色、フォント、スペーシング）**

---

### Tutorial 6: JavaScript 基礎とDOM操作（13セクション）

**学習目標**: プログラミング言語JavaScriptの基本文法を習得し、Webページを動的に操作する仕組みを理解する。

**到達レベル**: JavaScriptでDOMを操作し、インタラクティブなUIを作成できる。

**推定学習時間**: 50時間

#### Chapter 1: JavaScriptの第一歩（6セクション）
- **1-1: JavaScriptとは？Webにおける役割**
- **1-2: 変数と定数（`let`, `const`, `var`の違い）**
- **1-3: データ型（数値、文字列、真偽値、配列、オブジェクト、`null`, `undefined`）**
- **1-4: 演算子（算術、比較、論理、代入）**
- **1-5: 型変換と型強制**
- **1-6: チャプターハンズオン：簡単な計算機を作成する**

#### Chapter 2: 制御構文と関数（5セクション）
- **2-1: 条件分岐（`if`, `else if`, `else`, `switch`）**
- **2-2: 繰り返し処理（`for`, `while`, `do-while`, `forEach`）**
- **2-3: 関数の定義と呼び出し（関数宣言、関数式）**
- **2-4: アロー関数と`this`の扱い**
- **2-5: チャプターハンズオン：九九の表を動的に生成する**

#### Chapter 3: DOM操作（2セクション）
- **3-1: DOM（Document Object Model）とは？**
- **3-2: チャプターハンズオン：シンプルなTodoリストを作成する**

---

### Tutorial 7: JavaScript 応用と非同期処理（12セクション）

**学習目標**: JavaScriptのより高度な概念を理解し、サーバーとの通信（API連携）に不可欠な非同期処理をマスターする。

**到達レベル**: `async/await`を使ってAPIからデータを取得し、エラーハンドリングができる。

**推定学習時間**: 50時間

#### Chapter 1: ES6+のモダンな機能（5セクション）
- **1-1: 分割代入（配列とオブジェクト）**
- **1-2: スプレッド構文（`...`）と残余引数**
- **1-3: `map`, `filter`, `reduce`などの配列操作メソッド**
- **1-4: テンプレートリテラル（バッククォート）**
- **1-5: チャプターハンズオン：配列メソッドを使ってデータ一覧をフィルタリングする**

#### Chapter 2: 非同期処理の基礎（5セクション）
- **2-1: 同期処理と非同期処理の違い**
- **2-2: コールバック関数とコールバック地獄**
- **2-3: `Promise`の概念（`pending`, `fulfilled`, `rejected`）**
- **2-4: `then`, `catch`, `finally`の使い方**
- **2-5: チャプターハンズオン：Promiseを使ってタイマー処理を作成する**

#### Chapter 3: `async/await`と実践的なAPI連携（2セクション）
- **3-1: `async/await`を使った直感的な非同期処理**
- **3-2: チャプターハンズオン：公開APIを使って天気予報アプリを作成する**

---

### Tutorial 8: TypeScript 基礎から実用へ（13セクション）

**学習目標**: 静的型付け言語TypeScriptを導入し、大規模なアプリケーションでも堅牢で保守性の高いコードを書くスキルを身につける。

**到達レベル**: TypeScriptで型を定義し、ジェネリクスやUtility Typesを適切に使える。

**推定学習時間**: 50時間

#### Chapter 1: TypeScript入門（5セクション）
- **1-1: なぜTypeScriptが必要なのか？（業務効率と事故防止）**
- **1-2: TypeScriptの環境構築（Node.js, npm, tsc）**
- **1-3: `tsconfig.json`の基本設定と理解**
- **1-4: 基本的な型（`string`, `number`, `boolean`, `any`）**
- **1-5: チャプターハンズオン：簡単な関数に型を付ける**

#### Chapter 2: 型の応用（5セクション）
- **2-1: 配列とオブジェクトの型定義**
- **2-2: Union型（`|`）とIntersection型（`&`）**
- **2-3: 型の絞り込み（Type Guard）と`typeof`, `instanceof`**
- **2-4: `null`と`undefined`の安全な扱い（Non-null Assertion）**
- **2-5: チャプターハンズオン：ユーザー情報のオブジェクトに型を定義する**

#### Chapter 3: 高度な型操作（3セクション）
- **3-1: ジェネリクス（Generics）による再利用可能な型の作成**
- **3-2: Utility Types（`Partial`, `Pick`, `Omit`, `Record`, `Readonly`）**
- **3-3: チャプターハンズオン：汎用的なAPIレスポンスの型をジェネリクスで作成する**

---

### Tutorial 9: React：宣言的UIとコンポーネントの基礎（18セクション）

**学習目標**: 現代フロントエンド開発の主流であるReactを習得し、コンポーネントベースの宣言的なUI構築手法をマスターする。

**到達レベル**: React Hooksを使ってコンポーネントを作成し、インタラクティブなUIを構築できる。

**推定学習時間**: 80時間

#### Chapter 1: Reactのコア概念と環境構築（5セクション）
- **1-1: なぜReactなのか？宣言的UIとコンポーネント思考**
- **1-2: JSXの基本ルールと構文**
- **1-3: Reactプロジェクトの作成（Vite）**
- **1-4: コンポーネントの作成とPropsによるデータ受け渡し**
- **1-5: チャプターハンズオン：プロフィールカードコンポーネントを作成する**

#### Chapter 2: React Hooksによる状態管理（6セクション）
- **2-1: `useState`による状態（state）管理と再レンダリングの関係**
- **2-2: イベントハンドリング（`onClick`, `onChange`）**
- **2-3: `useEffect`による副作用（API通信など）の管理**
- **2-4: 依存配列の理解と誤解しやすいポイント**
- **2-5: カスタムフックによるロジックの再利用**
- **2-6: チャプターハンズオン：カウンターアプリとタイマーアプリを作成する**

#### Chapter 3: フォーム実装と状態共有（4セクション）
- **3-1: 制御コンポーネントによるフォーム作成**
- **3-2: `useContext`によるシンプルな状態共有（テーマ切り替えなど）**
- **3-3: `useReducer`による複雑な状態管理**
- **3-4: チャプターハンズオン：useContextを使ってテーマ切り替え機能付きTodoアプリを作成する**

#### Chapter 4: Reactのパフォーマンス最適化入門（3セクション）
- **4-1: `React.memo`による不要な再レンダリングの防止**
- **4-2: `useMemo`と`useCallback`の適切な使い方**
- **4-3: チャプターハンズオン：Todoアプリのパフォーマンスを最適化する**

---

### Tutorial 10: Webレンダリングの深層理解（15セクション）

**学習目標**: フロントエンド開発における最重要概念である「レンダリング」を、ブラウザの動作原理からReactの内部実装、そして最新のアーキテクチャまで、歴史的背景と共に体系的に理解する。

**到達レベル**: CSR, SSR, SSGの違いを説明でき、仮想DOMの役割を理解している。

**推定学習時間**: 60時間（必須） + 30時間（オプショナル）

#### Chapter 1: レンダリングとは何か？ - 3つの視点（5セクション）
- **1-1: 広義のレンダリング（データから視覚情報への変換）**
- **1-2: ブラウザにおけるレンダリング（The Pixel Pipeline, レンダリングエンジン, Blink）**
- **1-3: Reactにおけるレンダリング（レンダーフェーズ、コミットフェーズ、ペイント）**
- **1-4: 仮想DOM（Virtual DOM）の概念と役割**
- **1-5: チャプターハンズオン：DevToolsでレンダリングの過程を観察する**

#### Chapter 2: レンダリング戦略の進化と歴史（4セクション）
- **2-1: MPAと古典的SSR（サーバーサイドテンプレートエンジン時代）**
- **2-2: CSRの登場とSPAの台頭（Backbone.jsなど）**
- **2-3: モダンSSRの誕生（Isomorphic JS, Rendr, Hydrationの概念）**
- **2-4: チャプターハンズオン：各時代のWebサイトのサンプルを動かしてみる**

#### Chapter 3: 各レンダリング戦略の詳解（3セクション）
- **3-1: Client-Side Rendering（CSR）の仕組みと長所・短所**
- **3-2: Server-Side Rendering（SSR）の仕組みと長所・短所**
- **3-3: Static Site Generation（SSG）の仕組みと長所・短所**

#### Chapter 4: 次世代のレンダリングモデル（3セクション）
- **4-1: React Server Components（RSC）vs SSR - 補完関係の理解**
- **4-2: Partial Prerendering（PPR）- 静的と動的の融合**
- **4-3: Islands ArchitectureとAstroの思想**

#### Chapter 5: 仮想DOMの実装（オプショナル）（2セクション）
- **5-1: 簡易版仮想DOMの実装と差分検出アルゴリズム**
- **5-2: チャプターハンズオン：Preactなどの軽量フレームワークの実装を読み解く**

---

### Tutorial 11: React応用：実務レベルの状態管理と設計（18セクション）

**学習目標**: 複雑化するアプリケーションの状態をサーバー・クライアントで分離して管理し、再利用性とメンテナンス性の高いコンポーネント設計手法を習得する。

**到達レベル**: TanStack QueryとZustandを使い分け、Atomic Designの思想に基づいたコンポーネント設計ができる。

**推定学習時間**: 80時間

#### Chapter 1: 実践的フォーム実装（5セクション）
- **1-1: `React Hook Form`によるフォーム状態管理（`useForm`, `register`）**
- **1-2: `Zod`によるスキーマベースのバリデーション**
- **1-3: エラーメッセージの表示とUIへのフィードバック**
- **1-4: 複雑なフォーム（条件付きフィールド、動的フィールド）の実装**
- **1-5: チャプターハンズオン：Zodでバリデーションする会員登録フォームを作成する**

#### Chapter 2: サーバー状態管理（TanStack Query）（5セクション）
- **2-1: `useQuery`によるデータ取得とキャッシュ戦略**
- **2-2: `Loading`, `Error`, `Empty`状態のUI分岐**
- **2-3: `useMutation`によるデータ更新（POST, PUT, DELETE）**
- **2-4: キャッシュの無効化と再取得（`invalidateQueries`）**
- **2-5: チャプターハンズオン：TanStack Queryを使ってAPIから記事一覧を取得・表示する**

#### Chapter 3: クライアント状態管理と設計パターン（4セクション）
- **3-1: グローバル状態管理の必要性とライブラリ選定**
- **3-2: `Zustand`によるシンプルな状態管理**
- **3-3: サーバー状態（TanStack Query）とクライアント状態（Zustand）の分離戦略**
- **3-4: チャプターハンズオン：Zustandでダークモードの状態を管理する**

#### Chapter 4: コンポーネント設計パターン（4セクション）
- **4-1: Atomic Designの思想とコンポーネントの粒度（Atoms, Molecules, Organisms）**
- **4-2: Presentational ComponentsとContainer Componentsの分離**
- **4-3: 大規模アプリケーションを見据えたディレクトリ構成戦略（feature-based, layer-based）**
- **4-4: チャプターハンズオン：Atomic Design思想でコンポーネントをリファクタリングする**

---

### Tutorial 12: 【ハンズオン】ゼロから始めるNext.jsプロジェクト（10セクション）

**学習目標**: `create-next-app`を使ってNext.jsプロジェクトをゼロから立ち上げ、実務で必須となる初期設定（ESLint, Prettier, Tailwind CSS）を自力で行えるようになる。

**到達レベル**: クリーンな状態のNext.jsプロジェクトに、静的解析ツールとCSSフレームワークを導入し、基本的なディレクトリ構成を整えられる。

**推定学習時間**: 40時間

#### Chapter 1: Next.jsプロジェクトのセットアップ（4セクション）
- **1-1: `create-next-app`によるプロジェクト作成とオプション解説**
  - プロジェクト作成時に選択すべきオプション（TypeScript, ESLint, Tailwind CSS）の意味と役割
  - 生成されるファイル構成の概要
  - 初期状態での開発サーバーの起動方法

- **1-2: 生成されたディレクトリとファイルの役割**
  - `app`ディレクトリ（App Router）の構成
  - `public`ディレクトリ（静的ファイル）の使い方
  - `package.json`の各スクリプトの意味

- **1-3: 開発サーバーの起動とホットリロードの確認**
  - `npm run dev`コマンドの実行
  - ホットリロード（Hot Module Replacement）の動作確認
  - ブラウザでの表示確認

- **1-4: チャプターハンズオン：`create-next-app`で自分のプロジェクトを作成する**

#### Chapter 2: 静的解析とコードフォーマットの導入（3セクション）
- **2-1: ESLintとPrettierの導入と設定**
  - ESLintの役割（コード品質チェック）
  - Prettierの役割（コードフォーマット）
  - `.eslintrc.json`と`.prettierrc.json`の基本設定

- **2-2: VSCodeとの連携による自動フォーマット設定**
  - VSCode拡張機能（ESLint, Prettier）のインストール
  - `settings.json`での自動フォーマット設定
  - 保存時の自動整形の確認

- **2-3: チャプターハンズオン：コード整形ルールをカスタマイズする**

#### Chapter 3: Tailwind CSSの導入とディレクトリ構成（3セクション）
- **3-1: Tailwind CSSの導入と`tailwind.config.ts`の設定**
  - Tailwind CSSが既に導入されている場合の確認
  - `tailwind.config.ts`でのテーマカスタマイズ
  - `globals.css`でのスタイル定義

- **3-2: 実務を想定したディレクトリ構成の作成（`components`, `features`, `lib`など）**
  - `components`ディレクトリ（再利用可能なコンポーネント）
  - `features`ディレクトリ（機能ごとのコンポーネント）
  - `lib`ディレクトリ（ユーティリティ関数）
  - `types`ディレクトリ（型定義）

- **3-3: チャプターハンズオン：共通レイアウトコンポーネントを作成する**

---

### Tutorial 13: Next.js：フルスタックフレームワークの実践（20セクション）

**学習目標**: ReactフレームワークであるNext.jsを使い、レンダリング戦略を意識したパフォーマンスの高いWebアプリケーションを構築し、実際にインターネットへ公開する。リアルタイム通信（WebSocket）の実装も学ぶ。

**到達レベル**: Next.jsのApp Routerを使いこなし、認証付きのWebアプリケーションをVercelにデプロイできる。

**推定学習時間**: 90時間

#### Chapter 1: Next.js（App Router）入門（5セクション）
- **1-1: Next.jsの役割とApp Routerの基本**
- **1-2: ファイルベースのルーティングとレイアウト**
- **1-3: ページとダイナミックルート（`[id]`）**
- **1-4: ネストされたレイアウトとルートグループ**
- **1-5: チャプターハンズオン：ブログサイトの基本的なルーティングを構築する**

#### Chapter 2: Server/Client Components（5セクション）
- **2-1: 「どこで動くか」を意識したコンポーネント設計**
- **2-2: Server Componentsでのデータ取得と直接DBアクセス**
- **2-3: Client ComponentsでのインタラクティブなUI実装**
- **2-4: Server ComponentsとClient Componentsの境界設計**
- **2-5: チャプターハンズオン：Server/Clientコンポーネントを使い分けて記事詳細ページを作成する**

#### Chapter 3: データ取得とキャッシュ（5セクション）
- **3-1: Server Componentsでのデータ取得とキャッシュ戦略**
- **3-2: Client Componentsでのデータ取得（SWR, TanStack Query）**
- **3-3: Server Actionsによるデータ更新**
- **3-4: Route HandlersによるAPIルートの作成**
- **3-5: チャプターハンズオン：Server Actionsを使ってコメント投稿機能を実装する**

#### Chapter 4: 認証・デプロイ・リアルタイム通信（5セクション）
- **4-1: 認証の実装（NextAuth.js）**
- **4-2: Middlewareによるリクエスト制御**
- **4-3: デプロイとCI/CD（Vercel）**
- **4-4: WebSocketによるリアルタイム通信の実装**
- **4-5: チャプターハンズオン：Next.jsでリアルタイムチャットアプリを構築しデプロイする**

---

### Tutorial 14: フロントエンドの品質保証とチーム開発（11セクション）

**学習目標**: 作成したアプリケーションの品質を保証するためのテスト手法を学び、チーム開発を円滑に進めるためのツールとプロセスを習得する。

**到達レベル**: Vitestで単体・結合テストを記述し、PlaywrightでE2Eテストを実行できる。Storybookでコンポーネントカタログを作成できる。

**推定学習時間**: 60時間

#### Chapter 1: テストの基礎（4セクション）
- **1-1: なぜテストが必要なのか？品質保証とリファクタリングの土台**
- **1-2: テストの種類（単体、結合、E2E）とテストピラミッド**
- **1-3: テスト環境の構築（Vitest, Testing Library）**
- **1-4: チャプターハンズオン：簡単なユーティリティ関数の単体テストを書く**

#### Chapter 2: コンポーネントテスト（4セクション）
- **2-1: `Vitest`と`Testing Library`による単体テスト**
- **2-2: `user-event`を使ったユーザー操作のシミュレーション**
- **2-3: モック（Mocking）の基礎（APIモック、関数モック）**
- **2-4: チャプターハンズオン：ログインフォームのコンポーネントテストを書く**

#### Chapter 3: E2Eテスト（3セクション）
- **3-1: `Playwright`によるE2Eテストの基礎**
- **3-2: 失敗しにくいテストの書き方（locator, 待ち、リトライ）**
- **3-3: チャプターハンズオン：会員登録からログインまでのE2Eテストを書く**

---

### Tutorial 15: パフォーマンス最適化と総仕上げ（8セクション）

**学習目標**: Webアプリケーションのパフォーマンスを計測・改善する手法を学び、2年目エンジニアとして自走するための総仕上げを行う。

**到達レベル**: Lighthouseを使ってパフォーマンスを計測し、Core Web Vitalsの指標を改善できる。

**推定学習時間**: 40時間

#### Chapter 1: パフォーマンスの計測（4セクション）
- **1-1: なぜパフォーマンスが重要なのか？（UXとビジネスインパクト）**
- **1-2: `Lighthouse`と`PageSpeed Insights`によるパフォーマンス計測**
- **1-3: Core Web Vitals（LCP, FID, CLS）の理解**
- **1-4: チャプターハンズオン：自分のポートフォリオサイトのパフォーマンスを計測する**

#### Chapter 2: Reactのパフォーマンス最適化（4セクション）
- **2-1: `React.memo`による不要な再レンダリングの防止**
- **2-2: `useMemo`と`useCallback`の適切な使い方**
- **2-3: `React DevTools Profiler`を使ったボトルネックの特定**
- **2-4: チャプターハンズオン：Next.jsブログのパフォーマンスを改善する**

---

### Tutorial 16: 【総合演習】Laravel × Next.js フルスタック開発（15セクション）

**学習目標**: バックエンド（Laravel）とフロントエンド（Next.js）を分離したモダンなWebアプリケーション開発の全体像を理解し、API連携における実践的な課題（CORS、認証など）を解決できるようになる。

**到達レベル**: LaravelでAPIを構築し、Next.jsからそのAPIを叩いて取得したデータを表示・操作する一連のフルスタック開発を一人で完遂できる。

**推定学習時間**: 80時間

#### Chapter 1: バックエンド（Laravel）の準備（5セクション）
- **1-1: LaravelプロジェクトのセットアップとDB設計**
  - Laravelプロジェクトの新規作成
  - 環境変数の設定（`.env`ファイル）
  - データベースの選択と接続設定
  - マイグレーションによるテーブル作成

- **1-2: APIルートの作成とコントローラーの実装**
  - RESTful APIの設計原則
  - ルートの定義（`routes/api.php`）
  - コントローラーの作成と基本的なCRUD操作

- **1-3: EloquentリソースによるJSONレスポンス整形**
  - Eloquent Resourcesの役割
  - APIレスポンスの標準化
  - ネストされたリソースの返却

- **1-4: API認証の導入（Laravel Sanctum）**
  - Sanctumのインストールと設定
  - トークンベース認証の実装
  - CORS設定の理解

- **1-5: チャプターハンズオン：CRUD操作が可能なTodo APIをLaravelで構築する**

#### Chapter 2: フロントエンド（Next.js）との連携（5セクション）
- **2-1: CORS（Cross-Origin Resource Sharing）の理解と設定**
  - CORSが必要な理由（オリジンの異なるリクエスト）
  - LaravelでのCORS設定（`config/cors.php`）
  - ブラウザのプリフライトリクエスト

- **2-2: Next.jsからLaravel APIを叩く（`fetch`と環境変数）**
  - 環境変数の設定（`NEXT_PUBLIC_API_URL`）
  - `fetch`を使ったAPI呼び出し
  - エラーハンドリングとステータスコード判定

- **2-3: 認証情報の受け渡しと状態管理（Cookieベース認証）**
  - ログイン時のトークン取得
  - `fetch`リクエストへのトークン付与
  - Zustandでの認証状態管理

- **2-4: `msw`を使ったAPIモックによるフロントエンド単体開発**
  - Mock Service Workerのセットアップ
  - APIエンドポイントのモック定義
  - フロントエンド開発の並列化

- **2-5: チャプターハンズオン：Next.jsでTodoリストのUIを作成し、API連携を実装する**

#### Chapter 3: フルスタックアプリケーションのデプロイ（5セクション）
- **3-1: バックエンド（Laravel）のデプロイ戦略（Heroku, VPSなど）**
  - Herokuへのデプロイ手順
  - 本番環境での環境変数設定
  - データベースマイグレーションの実行

- **3-2: フロントエンド（Next.js）のデプロイ（Vercel）**
  - Vercelへのプロジェクト接続
  - 環境変数の設定（API_URLなど）
  - 自動デプロイの設定

- **3-3: 本番環境での環境変数の設定**
  - バックエンド・フロントエンド間の環境変数の分離
  - セキュリティを考慮した設定方法

- **3-4: CI/CDパイプラインの概要**
  - GitHub Actionsの基本
  - テスト自動実行の設定
  - 本番環境への自動デプロイ

- **3-5: チャプターハンズオン：作成したフルスタックTodoアプリを公開する**

---

## 📊 全体の学習時間配分

| Tutorial | 時間 | 累計 |
| :--- | ---: | ---: |
| Tutorial 1 | 30時間 | 30時間 |
| Tutorial 2 | 40時間 | 70時間 |
| Tutorial 3 | 40時間 | 110時間 |
| Tutorial 4 | 30時間 | 140時間 |
| Tutorial 5 | 40時間 | 180時間 |
| Tutorial 6 | 50時間 | 230時間 |
| Tutorial 7 | 50時間 | 280時間 |
| Tutorial 8 | 50時間 | 330時間 |
| Tutorial 9 | 80時間 | 410時間 |
| Tutorial 10 | 60時間 | 470時間 |
| Tutorial 11 | 80時間 | 550時間 |
| Tutorial 12 | 40時間 | 590時間 |
| Tutorial 13 | 90時間 | 680時間 |
| Tutorial 14 | 60時間 | 740時間 |
| Tutorial 15 | 40時間 | 780時間 |
| Tutorial 16 | 80時間 | 860時間 |

**合計**: 約860時間（約1年の学習を想定）

---

## 📋 執筆時の注意事項

### 1. 文字数の厳格な管理
- **各セクション**: 3,000～6,000文字
- **ハンズオンセクション内の実践パート**: 3,000～5,000文字
- 文字数が不足している場合は、より詳細な解説を追加する

### 2. 初学者への配慮
- 専門用語を使う際は、必ず初出時に定義・説明を加える
- 比喩表現は効果的に使用するが、強すぎる表現は避ける
- 「なぜ？」という問いかけを大切にし、学習者の理解を深める

### 3. 実践性の重視
- すべてのセクションに、実際に手を動かすハンズオンを含める
- コードサンプルは実行可能で、学習者が即座に試せるものにする
- エラーメッセージやよくあるつまずきポイントを先回りして解説する

### 4. 一貫性の維持
- 全チュートリアルを通じて、同じ用語・表現を使用する
- コード例のスタイル（インデント、命名規則）を統一する
- 各セクションの構成（見出し、段落、表）を統一する

### 5. 参考資料の引用
- 外部リソース（公式ドキュメント、記事など）を引用する際は、必ずURLを記載する
- 引用元の著者・出版元を明記する

---

## 🎯 チュートリアル間の連携

### 学習の流れ
1. **Tutorial 1-5**: Webの基礎、開発環境、CSS基礎、依存関係ツール、Tailwind CSSを習得
2. **Tutorial 6-8**: JavaScriptとTypeScriptの基本を習得
3. **Tutorial 9**: Reactの基礎を習得
4. **Tutorial 10**: レンダリングの深層理解（Reactの背景にある仕組み）
5. **Tutorial 11**: React応用（実務レベルの状態管理と設計）
6. **Tutorial 12**: Next.jsプロジェクトのセットアップ
7. **Tutorial 13**: Next.jsでの実装と公開
8. **Tutorial 14**: テストとチーム開発
9. **Tutorial 15**: パフォーマンス最適化
10. **Tutorial 16**: フルスタック開発の総合演習

### 各チュートリアル間の参照
- 前のチュートリアルで学んだ概念を、後のチュートリアルで活用する
- 「Tutorial Xで学んだ〇〇を思い出してください」という形で、学習者の記憶を活性化させる
- 各チュートリアルの最後に「次のチュートリアルで学ぶこと」を予告する

---

## 🚀 最後に

このガイドラインは、フロントエンドエンジニアとしての2年目を目指す学習者が、実務で即戦力となるスキルを身につけるための指針です。

執筆者は、常に「学習者の視点」を忘れず、「なぜこれを学ぶのか」「どう実務で使うのか」を明確にしながら、親しみやすく、かつ深い理解を促す教材を作成してください。

特に、Tutorial 12と16は、ハンズオン中心の実践的な内容となります。学習者が「実際に手を動かして、動くものを作る」という体験を通じて、自信と達成感を得られるよう、丁寧かつ詳細な解説を心がけてください。
