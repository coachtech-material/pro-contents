# 7-3-3: 子から親へのイベント通知（コールバック関数）

## 🎯 このセクションで学ぶこと

- 子コンポーネントで発生したイベントを親コンポーネントに伝える方法を理解する
- 親のStateを更新するための関数を、Propsとして子に渡す（**コールバック関数**）パターンを習得する
- **状態のリフトアップ（Lifting State Up）**という、Reactにおける状態管理の重要な設計思想を学ぶ

## 導入

前のセクションで、データは親から子へPropsを通じて流れること、そしてPropsは読み取り専用であることを学びました。しかし、実際のアプリケーションでは、子の内部で起きたイベント（例: ボタンがクリックされた、フォームが入力された）に応じて、親が持つStateを更新したい場面が頻繁にあります。

データフローはトップダウンなのに、どうやって下から上へ情報を伝えればよいのでしょうか？

その答えが、**コールバック関数をPropsとして渡す**というテクニックです。親コンポーネントでStateを更新するロジックを持つ関数を定義し、その関数自体をPropsとして子に渡します。子は、何かイベントが発生したタイミングで、受け取ったその関数を呼び出します。これにより、実質的に「子から親へイベントを通知」し、親のStateを変更することが可能になります。このパターンは**状態のリフトアップ**と呼ばれます。

## 詳細解説

### 🔑 状態のリフトアップ (Lifting State Up)

状態のリフトアップとは、複数のコンポーネントで共有される必要があるStateを、それらのコンポーネントの**最も近い共通の親**に配置するという設計原則です。

例えば、ヘッダーコンポーネントに現在のユーザー名を表示し、メインコンテンツ内のボタンでユーザー名を変更できるようにしたい場合、ユーザー名のStateはヘッダーやメインコンテンツではなく、それらを両方とも子に持つ `App` コンポーネントなどに配置する必要があります。

そして、Stateを更新する関数 (`set`関数) をラップした独自の関数を、Stateを更新する必要がある子コンポーネントにPropsとして渡していきます。

### 実装例: 子のボタンで親のカウンターを更新する

親がカウンターのStateを持ち、子がそのカウンターを増やすボタンを持つ、というシンプルな例で見ていきましょう。

#### 1. 親コンポーネントの定義

親コンポーネント `CounterApp` は、`count` のStateと、それを更新する `increment` 関数を定義します。そして、`count` の値と `increment` 関数の両方を子コンポーネント `ChildButton` にPropsとして渡します。

```tsx
// src/components/CounterApp.tsx
import React, { useState } from 'react';
import ChildButton from './ChildButton';

function CounterApp() {
  // ① Stateを親コンポーネントで管理する
  const [count, setCount] = useState(0);

  // ② Stateを更新するための関数を定義する
  const increment = () => {
    setCount(prevCount => prevCount + 1);
  };

  return (
    <div>
      <h1>Counter App</h1>
      <p>Current Count: {count}</p>
      {/* ③ Stateの値と、Stateを更新する関数を子に渡す */}
      <ChildButton onIncrement={increment} />
    </div>
  );
}

export default CounterApp;
```

#### 2. 子コンポーネントの定義

子コンポーネント `ChildButton` は、親から渡される `onIncrement` という名前の関数を受け取ります。この関数の型定義が重要です。

```tsx
// src/components/ChildButton.tsx
import React from 'react';

// ① 受け取るpropsの型を定義する
interface ChildButtonProps {
  // onIncrementは、引数を取らず、何も返さない (void) 関数である
  onIncrement: () => void;
}

const ChildButton: React.FC<ChildButtonProps> = ({ onIncrement }) => {
  return (
    // ② ボタンがクリックされたら、親から渡された関数を呼び出す
    <button onClick={onIncrement}>
      Increment Count
    </button>
  );
};

export default ChildButton;
```

- **`onIncrement: () => void;`**: `onIncrement` Propの型を定義しています。「引数なし、戻り値なし」の関数であることを示しています。もし子が親にデータを渡したい場合は、`onUpdate: (newValue: string) => void` のように引数を定義します。
- **`onClick={onIncrement}`**: ボタンの`onClick`イベントに、親から渡された `onIncrement` 関数をそのまま設定しています。これにより、ボタンがクリックされると、親コンポーネントの `increment` 関数が実行され、親の `count` Stateが更新されます。

### データフローのまとめ

1.  **データ（State）の下降**: 親 `CounterApp` が持つ `count` Stateが、Propsを通じて子 `ChildButton` に渡される（この例では表示は親が担当）。
2.  **イベント（アクション）の上昇**: 子 `ChildButton` のボタンがクリックされると、Propsとして渡された `onIncrement` 関数が呼び出される。この関数は実際には親の `increment` 関数なので、親のスコープで実行され、親の `count` Stateが更新される。
3.  **再レンダリング**: 親のStateが更新されたため、親 `CounterApp` が再レンダリングされ、更新された `count` の値が画面に表示される。

このように、データは常に上から下へ流れますが、コールバック関数を使うことで、下からのイベントを上に伝え、状態変化のサイクルを回すことができます。

## ✨ まとめ

- 子コンポーネントから親コンポーネントのStateを更新するには、**状態のリフトアップ**という考え方を用いる。
- 具体的には、Stateとそれを更新するロジックを**共通の親コンポーネント**に持たせる。
- 親は、Stateを更新するための**コールバック関数**を定義し、それをPropsとして子に渡す。
- 子は、ユーザーのアクションなどに応じて、Propsで受け取ったコールバック関数を呼び出す。
- これにより、Reactの**単一方向データフロー**の原則を維持したまま、コンポーネント間のインタラクションを実現できる。
