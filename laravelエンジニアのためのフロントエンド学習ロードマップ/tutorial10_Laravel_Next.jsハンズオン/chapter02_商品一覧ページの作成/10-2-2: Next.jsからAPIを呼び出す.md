# 10-2-2: Next.jsからAPIを呼び出す

## 🎯 このセクションで学ぶこと

-   Next.jsのServer Componentから外部API（Laravel API）を`fetch`する方法を学ぶ
-   環境変数（`.env.local`）を使って、APIのベースURLを安全に管理する方法を習得する
-   取得したデータの型をTypeScriptで定義し、安全に扱う方法を学ぶ
-   CORS（Cross-Origin Resource Sharing）エラーとは何か、そしてなぜ発生するのかを理解する

## 導入

バックエンドに商品APIが準備できました。次はいよいよ、フロントエンド（Next.js）からこのAPIを呼び出し、商品データを取得します。

Next.jsのApp Routerでは、Server Componentがデフォルトです。Server Componentはサーバーサイドで実行されるため、`fetch` APIを使って外部のAPIサーバーと直接通信することができます。これは、PHP（Laravel）で`curl`や`Guzzle`を使って他のAPIを叩くのと似た感覚です。

このセクションでは、商品一覧を表示するための新しいページ（`/products`）を作成し、そのページのServer Componentから、先ほど作成したLaravelのAPI（`http://localhost/api/products`）を呼び出します。

## 詳細解説

### ステップ1: 環境変数の設定

APIのエンドポイントURLをコード内に直接書き込む（ハードコーディングする）のは良い習慣ではありません。開発環境と本番環境でURLが異なる場合に対応しづらくなりますし、URLが変更された際の修正も大変です。

そこで、環境変数を使ってAPIのベースURLを管理します。Next.jsプロジェクトのルートに`.env.local`というファイルを作成し、以下のように記述してください。

```.env
# .env.local

NEXT_PUBLIC_API_BASE_URL=http://localhost/api
```

-   `.env.local`: このファイルに定義された環境変数は、ローカル開発環境でのみ読み込まれます。Gitの管理対象から除外（`.gitignore`に記載済み）されているため、個人の環境設定や秘密情報を安全に管理できます。
-   `NEXT_PUBLIC_`: Next.jsでは、プレフィックスとして`NEXT_PUBLIC_`が付いた環境変数のみが、ブラウザ側（Client Component）でもアクセス可能な変数として扱われます。今回はServer Componentからのみアクセスしますが、今後の拡張性を考えて付けておくのが一般的です。

**重要**: `.env.local`ファイルを変更した後は、Next.jsの開発サーバーを一度停止し、再度`npm run dev`で起動し直す必要があります。

### ステップ2: 商品ページの作成とAPI呼び出し

次に、商品一覧を表示するためのページを作成します。

1.  `src/app/`ディレクトリの中に`products/`という新しいディレクトリを作成します。
2.  `src/app/products/`の中に`page.tsx`というファイルを作成します。

`src/app/products/page.tsx`に、APIを呼び出してデータを取得するコードを記述します。

```tsx
// src/app/products/page.tsx

// APIから返される商品データの型を定義
interface Product {
  id: number;
  name: string;
  description: string;
  price: number;
  created_at: string;
  updated_at: string;
}

// 商品データを取得するための非同期関数
async function getProducts(): Promise<Product[]> {
  const url = `${process.env.NEXT_PUBLIC_API_BASE_URL}/products`;
  console.log(`Fetching data from: ${url}`); // デバッグ用にURLをログ出力

  const res = await fetch(url, {
    // SSRではキャッシュが強力に効くため、開発中はキャッシュを無効にする
    cache: "no-store",
  });

  if (!res.ok) {
    // エラーハンドリング
    throw new Error("Failed to fetch products");
  }

  return res.json();
}

// 商品一覧ページのコンポーネント (Server Component)
export default async function ProductsPage() {
  const products = await getProducts();

  return (
    <main className="container mx-auto p-8">
      <h1 className="text-3xl font-bold mb-8">商品一覧</h1>
      {/* 取得したデータをとりあえずJSON形式で表示してみる */}
      <pre className="bg-gray-100 p-4 rounded-lg">
        {JSON.stringify(products, null, 2)}
      </pre>
    </main>
  );
}
```

**コードのポイント:**

-   **型定義**: `interface Product`で、APIから受け取るデータの構造を定義しています。これにより、`product.name`のようなプロパティアクセス時にエディタの補完が効き、タイプミスを防ぐことができます。
-   **Server Component**: `ProductsPage`コンポーネントは`async`キーワード付きで定義されています。これにより、コンポーネントのレンダリングを`await getProducts()`の完了まで待たせることができます。これはServer Componentならではの機能です。
-   **`fetch`の実行**: `getProducts`関数内で、`fetch`を使ってLaravelのAPIを呼び出しています。URLは`.env.local`から読み込んだ環境変数を使って組み立てています。
-   **キャッシュの無効化**: `fetch(url, { cache: "no-store" })`は、Next.jsの強力なキャッシュ機能を一時的に無効にするためのオプションです。開発中にAPIのレスポンスを変更しても、古いデータが表示され続けるのを防ぎます。本番環境では、`{ next: { revalidate: 60 } }`のように、適切なキャッシュ戦略を設定します。

### ステップ3: CORSエラーとの遭遇

開発サーバーを再起動し、ブラウザで`http://localhost:3000/products`にアクセスしてみてください。ページには何も表示されず、ブラウザのコンソールと、Next.jsの開発サーバーのターミナル（VSCodeのターミナルなど）の両方に、以下のような**CORSエラー**が表示されるはずです。

**ブラウザのコンソール:**

```
Access to fetch at 'http://localhost/api/products' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

**Next.jsサーバーのターミナル:**

```
Error: Failed to fetch products
... (エラー詳細)
```

これは正常な動作です。なぜこのエラーが起こるのでしょうか？

#### CORS (Cross-Origin Resource Sharing) とは？

CORSは、Webブラウザが持つセキュリティ機能の一つです。デフォルトでは、ブラウザは**異なるオリジン**からのリソース読み込みをブロックします。

-   **オリジン**: スキーム（`http`）、ホスト（`localhost`）、ポート（`:3000`）の組み合わせ。

今回のケースでは、

-   リクエスト元: Next.jsアプリケーション (`http://localhost:3000`)
-   リクエスト先: Laravel API (`http://localhost:80` ※ポート80は省略されている)

となり、ポート番号が異なるため「異なるオリジン」と判断されます。そのため、ブラウザ（正確には、Next.jsサーバーがブラウザのように振る舞っている）は、Laravel APIからのレスポンスに「`http://localhost:3000`からのリクエストを許可しますよ」という特別なヘッダー（`Access-Control-Allow-Origin`）が含まれていない限り、リソースの読み込みをブロックします。

この問題を解決するには、**サーバーサイド（Laravel側）**で、「このオリジンからのリクエストは安全なので許可します」と設定してあげる必要があります。

## ✨ まとめ

-   Next.jsのServer Componentでは、`async/await`を使ってコンポーネント内で直接`fetch`によるAPI呼び出しができる。
-   APIのURLなどは`.env.local`ファイルに環境変数として定義し、`process.env`でアクセスするのが定石である。
-   TypeScriptの`interface`でAPIレスポンスの型を定義することで、コードの安全性が向上する。
-   異なるオリジン間でAPI通信を行うと、デフォルトでブラウザのCORSポリシーによってブロックされる。

CORSエラーは、多くの初学者がつまずくポイントですが、その仕組みを理解すれば怖くありません。次のセクションでは、このCORSエラーを解決するために、Laravel側で必要な設定を行っていきます。
