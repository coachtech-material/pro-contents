<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>クリーンアップ関数 | Laravelエンジニアのためのフロントエンド学習ロードマップ</title>
    <meta name="description" content="PHP/Laravelエンジニアがフロントエンド開発を習得するための教材">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="outer">
        <header>
            <h1><a href="index.html">Laravelエンジニアのためのフロントエンド学習ロードマップ</a></h1>
            <p class="description">PHP/Laravelエンジニアがフロントエンド開発を習得するための教材</p>
        </header>
        <div id="container">
            <aside>
                <div id="side-inner">
                    <div class="side-title">チュートリアル一覧</div>
<div class="side"><ul>
<li><a href="tutorial01_開発環境とWebの基礎固め.html">Tutorial 1: 開発環境とWebの基礎固め</a></li>
<li><a href="tutorial02_HTML_CSS基礎.html">Tutorial 2: HTML/CSS基礎</a></li>
<li><a href="tutorial03_Tailwind_CSS徹底習得.html">Tutorial 3: Tailwind CSS徹底習得</a></li>
<li><a href="tutorial04_JavaScript_基礎とDOM操作.html">Tutorial 4: JavaScript基礎とDOM操作</a></li>
<li><a href="tutorial05_JavaScript_応用と非同期処理.html">Tutorial 5: JavaScript応用と非同期処理</a></li>
<li><a href="tutorial06_TypeScript入門.html">Tutorial 6: TypeScript入門</a></li>
<li><a href="tutorial07_React入門.html">Tutorial 7: React入門</a></li>
<li><a href="tutorial08_React応用.html" class="current">Tutorial 8: React応用</a></li>
<li><a href="tutorial09_Next.js.html">Tutorial 9: Next.js</a></li>
<li><a href="tutorial10_Laravel_x_Next.js.html">Tutorial 10: Laravel × Next.js</a></li>
<li><a href="tutorial11_テスト.html">Tutorial 11: テスト</a></li>
<li><a href="tutorial12_column.html">上級コラム: Webレンダリングの深層理解</a></li>
</ul></div>

                </div>
            </aside>
            <div id="content">
                <div class="inner">
                    <div class="breadcrumb"><a href="index.html">ホーム</a><span>></span><a href="tutorial08_React応用.html">Tutorial 8: React応用</a><span>></span><a href="tutorial08_React応用_chapter01_useEffectによる副作用の管理.html">Chapter 1: useEffectによる副作用の管理</a><span>></span>クリーンアップ関数</div>
                    <div class="section-content">
<h1 id="8-1-3">8-1-3: クリーンアップ関数</h1>
<h2 id="chapter-1-useeffect">Chapter 1: <code>useEffect</code>による副作用の管理</h2>
<h3 id="section-3">Section 3: クリーンアップ関数</h3>
<p>🎯 <strong>このセクションで学ぶこと</strong></p>
<ul>
<li>副作用の「後片付け」である<strong>クリーンアップ</strong>の必要性を理解する。</li>
<li><code>useEffect</code>の副作用関数から<strong>クリーンアップ関数</strong>を返す方法を習得する。</li>
<li>クリーンアップ関数が実行される2つの主要なタイミングを説明できるようになる。</li>
</ul>
<hr />
<h3 id="_1">イントロダクション：副作用の「やりっぱなし」は危険</h3>
<p><code>useEffect</code>で副作用を開始するのは簡単ですが、場合によっては、その副作用を<strong>終了</strong>または<strong>キャンセル</strong>する必要があります。これを怠ると、メモリリークや意図しない挙動の原因となります。</p>
<p>例えば、<br />
-   <code>setInterval</code>でタイマーを開始したら、コンポーネントが不要になったときにタイマーを停止しないと、永遠に動き続けてしまう。<br />
-   <code>window</code>にイベントリスナーを追加したら、コンポーネントが不要になったときに解除しないと、メモリリークに繋がる。<br />
-   APIリクエストを送信した後、レスポンスが返ってくる前にコンポーネントがアンマウントされたら、そのレスポンスを使ってStateを更新しようとしてエラーになる。</p>
<p>このような「やりっぱなし」の副作用を片付けるための仕組みが、<code>useEffect</code>の<strong>クリーンアップ関数</strong>です。</p>
<hr />
<h3 id="_2">⚙️ クリーンアップ関数の構文</h3>
<p>クリーンアップ処理を登録するには、<code>useEffect</code>の第一引数である副作用関数から、<strong>関数を返します</strong>。この返された関数がクリーンアップ関数となります。</p>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  // 1. 副作用の処理（例：イベントリスナーの登録）
  console.log(&quot;副作用が開始されました&quot;);
  window.addEventListener(&quot;scroll&quot;, handleScroll);

  // 2. クリーンアップ関数を返す
  return () =&gt; {
    // 3. 副作用の片付け処理（例：イベントリスナーの解除）
    console.log(&quot;クリーンアップが実行されました&quot;);
    window.removeEventListener(&quot;scroll&quot;, handleScroll);
  };
}, []); // 依存配列
</code></pre>

<hr />
<h3 id="_3">🚀 クリーンアップ関数が実行されるタイミング</h3>
<p>クリーンアップ関数は、主に2つのタイミングで実行されます。</p>
<h4 id="1">タイミング1：コンポーネントがアンマウントされるとき</h4>
<p>コンポーネントが画面から消える（アンマウントされる）直前に、最後の後片付けとして実行されます。</p>
<p><strong>例：タイマーのクリーンアップ</strong></p>
<pre class="codehilite"><code class="language-tsx">function Timer() {
  const [time, setTime] = useState(0);

  useEffect(() =&gt; {
    // 1秒ごとにtimeをインクリメントするタイマーを開始
    const intervalId = setInterval(() =&gt; {
      setTime(t =&gt; t + 1);
    }, 1000);

    // コンポーネントがアンマウントされるときにタイマーを停止
    return () =&gt; {
      clearInterval(intervalId);
    };
  }, []); // 初回レンダリング時に一度だけ実行

  return &lt;div&gt;Time: {time}&lt;/div&gt;;
}
</code></pre>

<p>もしクリーンアップがないと、この<code>Timer</code>コンポーネントが画面から消えても、<code>setInterval</code>はバックグラウンドで動き続け、メモリを消費し続けます。</p>
<h4 id="2">タイミング2：次の副作用が実行される直前</h4>
<p>依存配列に値が指定されている場合、その値が変更されて<strong>次の副作用が実行される直前</strong>に、前回の副作用に対するクリーンアップが実行されます。</p>
<p><strong>「次の副作用の前に、前回の副作用を片付ける」</strong>というイメージです。</p>
<p><strong>例：特定のユーザーIDを購読する</strong></p>
<pre class="codehilite"><code class="language-tsx">function UserProfile({ userId }) {
  useEffect(() =&gt; {
    // 1. 新しいuserIdでチャットサーバーに接続
    const connection = connectToChat(userId);

    // 2. userIdが変更されたら、次の接続の前に古い接続を切断する
    return () =&gt; {
      disconnectFromChat(connection);
    };
  }, [userId]); // userIdに依存

  return &lt;h1&gt;Welcome, User {userId}!&lt;/h1&gt;;
}
</code></pre>

<p>このコンポーネントの<code>userId</code>が<code>1</code>から<code>2</code>に変わったときの流れは以下のようになります。</p>
<ol>
<li><code>userId</code>が<code>2</code>に変わり、コンポーネントが再レンダリングされる。</li>
<li>Reactは<code>useEffect</code>の依存配列<code>[userId]</code>が変更されたことを検知する。</li>
<li><strong>（クリーンアップ）</strong> 前回の<code>userId=1</code>の副作用に対するクリーンアップ関数（<code>disconnectFromChat(connectionForUser1)</code>）を実行する。</li>
<li><strong>（次の副作用）</strong> 今回の<code>userId=2</code>の副作用関数（<code>connectToChat(2)</code>）を実行する。</li>
</ol>
<p>これにより、常に一つの<code>userId</code>に対する接続だけがアクティブな状態に保たれます。</p>
<hr />
<h3 id="_4">🔒 クリーンアップが必要ない場合</h3>
<p>すべての副作用にクリーンアップが必要なわけではありません。</p>
<p>例えば、一度きりのAPIリクエスト（<code>fetch</code>）のように、後片付けが不要な副作用もあります。その場合は、副作用関数から何も返す必要はありません。</p>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  // fetchは完了したら自動的に終了するので、クリーンアップは不要
  fetch(&quot;/api/data&quot;).then(...);
}, []);
</code></pre>

<p>ただし、この場合でも、レスポンスが返る前にコンポーネントがアンマウントされる可能性を考慮した、より高度なクリーンアップ（リクエストのキャンセル）が存在します。これは次のセクションで学びます。</p>
<hr />
<p>✨ <strong>まとめ</strong></p>
<ul>
<li>副作用の後片付けを行うために、<code>useEffect</code>の副作用関数から<strong>クリーンアップ関数</strong>を返すことができる。</li>
<li>クリーンアップ関数は、以下のタイミングで実行される。<ol>
<li><strong>コンポーネントがアンマウントされるとき</strong></li>
<li><strong>依存配列の値が変わり、次の副作用が実行される直前</strong></li>
</ol>
</li>
<li>タイマーの停止、イベントリスナーの解除、ネットワーク接続の切断など、継続的な副作用にはクリーンアップが不可欠である。</li>
</ul>
<p>📝 <strong>学習のポイント</strong></p>
<ul>
<li>[ ] <code>useEffect</code>のクリーンアップは、PHPの<code>__destruct</code>やJavaの<code>finally</code>ブロックと似ている点、違う点は何でしょうか？</li>
<li>[ ] 依存配列が空<code>[]</code>の場合、クリーンアップ関数が実行されるのはいつですか？</li>
<li>[ ] 依存配列を省略した場合、クリーンアップ関数はいつ実行されるでしょうか？ このパターンの挙動を想像してみましょう。</li>
</ul>
</div>
<div class="section-nav">
<a href="tutorial08_React応用_chapter01_useEffectによる副作用の管理_8-1-2: useEffectフックの使い方.html" class="prev">useEffectフックの使い方</a>
<a href="tutorial08_React応用_chapter01_useEffectによる副作用の管理_8-1-4: React_Strict_ModeとuseEffectの2回実行.html" class="next">React_Strict_ModeとuseEffectの2回実行</a>
</div>

                </div>
            </div>
        </div>
        <footer>
            &copy; 2025 Laravelエンジニアのためのフロントエンド学習ロードマップ
        </footer>
    </div>
</body>
</html>
