<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>キャッシュ戦略 | pro-contents</title>
    <meta name="description" content="Pro生用プログラミング教材コンテンツ">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div id="outer">
        <header>
            <h1><a href="index.html">pro-contents</a></h1>
            <p class="description">Pro生用プログラミング教材コンテンツ</p>
        </header>
        <div id="container">
            <aside>
                <div id="side-inner">
                    <div class="side-title">チュートリアル一覧</div>
<div class="side"><ul>
<li><a href="tutorial01_開発環境とWebの基礎固め.html">Tutorial 1: 開発環境とWebの基礎固め</a></li>
<li><a href="tutorial02_HTML_CSS基礎.html">Tutorial 2: HTML/CSS基礎</a></li>
<li><a href="tutorial03_Tailwind_CSS徹底習得.html">Tutorial 3: Tailwind CSS徹底習得</a></li>
<li><a href="tutorial04_JavaScript_基礎とDOM操作.html">Tutorial 4: JavaScript基礎とDOM操作</a></li>
<li><a href="tutorial05_JavaScript_応用と非同期処理.html">Tutorial 5: JavaScript応用と非同期処理</a></li>
<li><a href="tutorial06_TypeScript入門.html">Tutorial 6: TypeScript入門</a></li>
<li><a href="tutorial07_React入門.html">Tutorial 7: React入門</a></li>
<li><a href="tutorial08_React応用.html">Tutorial 8: React応用</a></li>
<li><a href="tutorial09_Next.js.html" class="current">Tutorial 9: Next.js</a></li>
<li><a href="tutorial10_Laravel_x_Next.js.html">Tutorial 10: Laravel × Next.js</a></li>
<li><a href="tutorial11_テスト.html">Tutorial 11: テスト</a></li>
<li><a href="tutorial12_column.html">上級コラム: Webレンダリングの深層理解</a></li>
</ul></div>

                </div>
            </aside>
            <div id="content">
                <div class="inner">
                    <div class="breadcrumb"><a href="../index.html">ホーム</a><span>></span><a href="index.html">Laravelエンジニアのためのフロントエンド学習ロードマップ</a><span>></span><a href="tutorial09_Next.js.html">Tutorial 9: Next.js</a><span>></span><a href="tutorial09_Next.js_chapter03_レンダリングとパフォーマンス.html">Chapter 3: レンダリングとパフォーマンス</a><span>></span>キャッシュ戦略</div>
                    <div class="section-content">
<h1 id="9-3-2">9-3-2: キャッシュ戦略</h1>
<h2 id="_1">🎯 このセクションで学ぶこと</h2>
<ul>
<li>Next.jsが持つ複数のキャッシュレイヤーの存在を理解する</li>
<li>サーバーサイドの<strong>Data Cache</strong>と<strong>Full Route Cache</strong>の役割と違いを学ぶ</li>
<li>クライアントサイドの<strong>Router Cache</strong>の役割を学ぶ</li>
<li>これらのキャッシュがどのように連携し、アプリケーションのパフォーマンスを向上させているかを理解する</li>
</ul>
<h2 id="_2">導入</h2>
<p>Next.jsの驚異的なパフォーマンスは、その高度で多層的なキャッシュ戦略によって支えられています。前のセクションで、<code>fetch</code>のオプションがレンダリング手法を決定すること、そしてそれがキャッシュと密接に関連していることを見ました。しかし、Next.jsのキャッシュは単一の仕組みではありません。サーバーサイドとクライアントサイドにまたがる複数のレイヤーで構成されており、それぞれが異なる役割を担っています。</p>
<p>このセクションでは、Next.jsのキャッシュシステムの全体像を解き明かします。特に重要な以下の3つのキャッシュレイヤーに焦点を当て、それぞれの役割と相互作用を理解することで、より高度なパフォーマンスチューニングを行うための知識を身につけます。</p>
<ol>
<li><strong>Data Cache</strong> (サーバーサイド): <code>fetch</code>リクエストの結果を保存する。</li>
<li><strong>Full Route Cache</strong> (サーバーサイド): ページのレンダリング結果（RSC PayloadとHTML）を保存する。</li>
<li><strong>Router Cache</strong> (クライアントサイド): ユーザーが訪れたページのレンダリング結果をブラウザのメモリに保存する。</li>
</ol>
<h2 id="_3">詳細解説</h2>
<h3 id="1-data-cache">1. Data Cache (データキャッシュ)</h3>
<p>Data Cacheは、サーバーサイドで<code>fetch</code>リクエストの結果を永続的に保存するためのキャッシュです。これは、Next.jsのビルドプロセスやサーバー環境に組み込まれており、複数のリクエストやデプロイメントをまたいでデータを保持することができます（Vercelのようなホスティング環境の場合）。</p>
<ul>
<li><strong>対象</strong>: <code>fetch</code> APIによるデータ取得の結果。</li>
<li><strong>制御方法</strong>: <code>fetch</code>のオプション（<code>cache: 'force-cache'</code>, <code>cache: 'no-store'</code>, <code>next: { revalidate: n }</code>）で制御します。</li>
<li><strong>役割</strong>: 同じデータソースへの重複したリクエストを防ぎ、ビルド時間やレンダリング時間を短縮します。例えば、レイアウトとページの両方で同じ<code>fetch</code>リクエストを呼び出しても、実際のリクエストは一度しか実行されません。</li>
</ul>
<pre class="codehilite"><code class="language-tsx">// このfetchの結果はData Cacheに保存される
await fetch(&quot;https://...&quot;, { next: { revalidate: 60 } });
</code></pre>

<h3 id="2-full-route-cache">2. Full Route Cache (フルルートキャッシュ)</h3>
<p>Full Route Cacheもサーバーサイドのキャッシュですが、こちらは<strong>ページのレンダリング結果そのもの</strong>をキャッシュします。静的にレンダリング可能なルート（<code>fetch</code>が<code>force-cache</code>を使用し、動的関数を含まないルート）が対象です。</p>
<ul>
<li><strong>対象</strong>: React Server Component (RSC) の出力（ペイロード）と、その結果生成されたHTML。</li>
<li><strong>タイミング</strong>: ビルド時に生成され、CDNに配置されます。</li>
<li><strong>役割</strong>: ユーザーからのリクエストに対して、レンダリング処理を一切行わず、事前に生成されたHTMLとRSCペイロードを即座に返すことで、最速のレスポンスを実現します。</li>
<li><strong>無効化 (Invalidation)</strong>: <code>fetch</code>で<code>cache: 'no-store'</code>や<code>revalidate</code>が使われている場合、または<code>cookies()</code>のような動的関数が使われている場合、そのルートはFull Route Cacheの対象外となり、リクエストごとに動的にレンダリングされます。</li>
</ul>
<p>Full Route Cacheは、SSG（静的サイト生成）の核となるキャッシュです。ユーザーがページにアクセスしたとき、Next.jsサーバーはまずFull Route Cacheを確認し、ヒットすればレンダリングをスキップしてキャッシュを返します。</p>
<h3 id="3-router-cache">3. Router Cache (ルーターキャッシュ)</h3>
<p>Router Cacheは、これまでの2つとは異なり、<strong>クライアントサイド（ユーザーのブラウザ）</strong> に存在するキャッシュです。ユーザーがアプリケーション内をナビゲーションする際の体験を高速化するために設計されています。</p>
<ul>
<li><strong>対象</strong>: ユーザーが訪れたルートのRSCペイロード。</li>
<li><strong>タイミング</strong>: ユーザーが<code>&lt;Link&gt;</code>コンポーネントを使ってページ間を移動した際に、RSCペイロードがメモリに保存されます。</li>
<li><strong>役割</strong>: ユーザーが一度訪れたページに再度アクセスした際、サーバーにリクエストを送ることなく、ブラウザのメモリに保存されたRSCペイロードを使って即座にページを描画します。これにより、「戻る」「進む」の操作や再訪が非常に高速になります。</li>
<li><strong>持続時間</strong>: セッション中のみ保持されます。ページをリロードするとキャッシュは破棄されます。</li>
<li><strong>プリフェッチ</strong>: <code>&lt;Link&gt;</code>コンポーネントがビューポートに入ると、Next.jsはリンク先のページのRSCペイロードを自動的に<strong>プリフェッチ（事前取得）</strong>してRouter Cacheに保存します。これにより、ユーザーがリンクをクリックしたときには、すでにデータが手元にある状態になり、瞬時にページ遷移が完了します。</li>
</ul>
<h3 id="_4">キャッシュの連携フロー</h3>
<p>これらのキャッシュは、以下のように連携して動作します。</p>
<ol>
<li>
<p><strong>ビルド時</strong>: Next.jsは静的なルートを検出し、<code>fetch</code>リクエストを実行します。その結果は<strong>Data Cache</strong>に保存されます。そして、そのデータを使ってページをレンダリングし、結果（HTMLとRSCペイロード）を<strong>Full Route Cache</strong>に保存します。</p>
</li>
<li>
<p><strong>ユーザーが初めてページにアクセス</strong>: リクエストがサーバーに届きます。</p>
<ul>
<li><strong>静的ルートの場合</strong>: サーバーは<strong>Full Route Cache</strong>からHTMLとRSCペイロードを取得し、即座にクライアントに返します。クライアントは受け取ったRSCペイロードを<strong>Router Cache</strong>に保存します。</li>
<li><strong>動的ルートの場合</strong>: サーバーはレンダリングを開始します。<code>fetch</code>を実行する際、まず<strong>Data Cache</strong>を確認し、有効なキャッシュがあればそれを使います。なければAPIなどにリクエストを送り、結果を<strong>Data Cache</strong>に保存します。最終的にレンダリングされたHTMLとRSCペイロードをクライアントに返し、クライアントはそれを<strong>Router Cache</strong>に保存します。</li>
</ul>
</li>
<li>
<p><strong>ユーザーが別のページに遷移 (<code>&lt;Link&gt;</code>)</strong>: ユーザーがリンクをクリックすると、クライアントはまず<strong>Router Cache</strong>を確認します。キャッシュがあれば、サーバーへのリクエストなしでページを即座に描画します。キャッシュがなければ、サーバーにRSCペイロードをリクエストします（このフローは2.と同じ）。</p>
</li>
<li>
<p><strong>ユーザーが「戻る」ボタンでページに戻る</strong>: ブラウザは<strong>Router Cache</strong>からページを復元するため、瞬時に表示が完了します。</p>
</li>
</ol>
<h2 id="_5">✨ まとめ</h2>
<ul>
<li>Next.jsは、パフォーマンスを最大化するために、複数のキャッシュレイヤーを効果的に利用している。</li>
<li><strong>Data Cache</strong>は<code>fetch</code>の結果をサーバーサイドで永続化し、データソースへの不要なアクセスを削減する。</li>
<li><strong>Full Route Cache</strong>は静的ページのレンダリング結果をサーバーサイド（CDN）にキャッシュし、最速の初回表示を実現する（SSGの核）。</li>
<li><strong>Router Cache</strong>はユーザーのブラウザメモリにRSCペイロードをキャッシュし、アプリケーション内のナビゲーションを瞬時に行う。</li>
<li>これらのキャッシュ戦略を理解することは、Next.jsアプリケーションのパフォーマンスのボトルネックを特定し、最適化を行う上で不可欠である。</li>
</ul>
</div>
<div class="section-nav">
<a href="tutorial09_Next.js_chapter03_レンダリングとパフォーマンス_9-3-1: レンダリング手法（SSR, SSG, ISR）.html" class="prev">レンダリング手法（SSR, SSG, ISR）</a>
<a href="tutorial09_Next.js_chapter03_レンダリングとパフォーマンス_9-3-3: パフォーマンス最適化.html" class="next">パフォーマンス最適化</a>
</div>

                </div>
            </div>
        </div>
        <footer>
            &copy; 2025 pro-contents
        </footer>
    </div>
</body>
</html>
