<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stateの更新とイベントハンドリング | pro-contents</title>
    <meta name="description" content="Pro生用プログラミング教材コンテンツ">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div id="outer">
        <header>
            <h1><a href="index.html">pro-contents</a></h1>
            <p class="description">Pro生用プログラミング教材コンテンツ</p>
        </header>
        <div id="container">
            <aside>
                <div id="side-inner">
                    <div class="side-title">チュートリアル一覧</div>
<div class="side"><ul>
<li><a href="tutorial01_開発環境とWebの基礎固め.html">Tutorial 1: 開発環境とWebの基礎固め</a></li>
<li><a href="tutorial02_HTML_CSS基礎.html">Tutorial 2: HTML/CSS基礎</a></li>
<li><a href="tutorial03_Tailwind_CSS徹底習得.html">Tutorial 3: Tailwind CSS徹底習得</a></li>
<li><a href="tutorial04_JavaScript_基礎とDOM操作.html">Tutorial 4: JavaScript基礎とDOM操作</a></li>
<li><a href="tutorial05_JavaScript_応用と非同期処理.html">Tutorial 5: JavaScript応用と非同期処理</a></li>
<li><a href="tutorial06_TypeScript入門.html">Tutorial 6: TypeScript入門</a></li>
<li><a href="tutorial07_React入門.html" class="current">Tutorial 7: React入門</a></li>
<li><a href="tutorial08_React応用.html">Tutorial 8: React応用</a></li>
<li><a href="tutorial09_Next.js.html">Tutorial 9: Next.js</a></li>
<li><a href="tutorial10_Laravel_x_Next.js.html">Tutorial 10: Laravel × Next.js</a></li>
<li><a href="tutorial11_テスト.html">Tutorial 11: テスト</a></li>
<li><a href="tutorial12_column.html">上級コラム: Webレンダリングの深層理解</a></li>
</ul></div>

                </div>
            </aside>
            <div id="content">
                <div class="inner">
                    <div class="breadcrumb"><a href="../index.html">ホーム</a><span>></span><a href="index.html">Laravelエンジニアのためのフロントエンド学習ロードマップ</a><span>></span><a href="tutorial07_React入門.html">Tutorial 7: React入門</a><span>></span><a href="tutorial07_React入門_chapter03_Stateによる状態管理.html">Chapter 3: Stateによる状態管理</a><span>></span>Stateの更新とイベントハンドリング</div>
                    <div class="section-content">
<h1 id="7-3-2-state">7-3-2: Stateの更新とイベントハンドリング</h1>
<h2 id="chapter-3-state">Chapter 3: Stateによる状態管理</h2>
<h3 id="section-2-state">Section 2: Stateの更新とイベントハンドリング</h3>
<p>🎯 <strong>このセクションで学ぶこと</strong></p>
<ul>
<li><code>onClick</code>や<code>onChange</code>といった、JSXでの<strong>イベントハンドリング</strong>の方法を習得する。</li>
<li>フォーム入力要素（<code>input</code>など）の値をStateで管理する、<strong>制御コンポーネント</strong>というパターンを理解する。</li>
<li>Stateの更新が非同期である問題に対応するため、セッター関数に<strong>更新関数</strong>を渡す方法を習得する。</li>
</ul>
<hr />
<h3 id="state">イントロダクション：ユーザーの操作をStateに反映する</h3>
<p><code>useState</code>でStateを宣言する方法は学びましたが、それをいつ、どのように更新するのでしょうか？ State更新のきっかけのほとんどは、ユーザーによる<strong>イベント</strong>です。</p>
<ul>
<li>ボタンのクリック (<code>click</code>)</li>
<li>フォームへの入力 (<code>change</code>)</li>
<li>フォームの送信 (<code>submit</code>)</li>
<li>マウスカーソルのホバー (<code>mouseover</code>)</li>
</ul>
<p>このセクションでは、これらのイベントをReactで処理する方法（イベントハンドリング）と、それを使ってStateを安全かつ正確に更新するテクニックを学びます。</p>
<hr />
<h3 id="jsx">⚙️ JSXでのイベントハンドリング</h3>
<p>JSXでイベントを処理するには、HTML要素に<code>camelCase</code>形式のイベントハンドラ属性（例: <code>onClick</code>, <code>onChange</code>）を渡します。属性値には、イベント発生時に実行したい<strong>関数</strong>を波括弧<code>{}</code>で囲んで指定します。</p>
<p><strong>❌ やってはいけないこと（関数を呼び出してしまう）:</strong></p>
<pre class="codehilite"><code class="language-jsx">// ページが表示された瞬間にhandleClickが実行されてしまう！
&lt;button onClick={handleClick()}&gt;Click me&lt;/button&gt;
</code></pre>

<p><strong>⭕ 正しい方法（関数そのものを渡す）:</strong></p>
<pre class="codehilite"><code class="language-jsx">&lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;
</code></pre>

<p>または、アロー関数を使ってインラインで定義することもできます。</p>
<pre class="codehilite"><code class="language-jsx">&lt;button onClick={() =&gt; alert(&quot;Clicked!&quot;)}&gt;Click me&lt;/button&gt;
</code></pre>

<h4 id="_1">イベントオブジェクト</h4>
<p>イベントハンドラ関数は、第一引数に<strong>イベントオブジェクト</strong>を受け取ることができます。これには、イベントに関する詳細な情報（どのキーが押されたか、マウスの座標はどこか、など）が含まれています。</p>
<p>特にフォーム要素で重要なのが、<code>event.target.value</code>です。これは、イベントが発生した要素（例: <code>input</code>タグ）の現在の値を取得するために使われます。</p>
<hr />
<h3 id="_2">🚀 フォーム入力と制御コンポーネント</h3>
<p>HTMLの<code>input</code>や<code>textarea</code>は、それ自身が内部に状態（ユーザーが入力した値）を持っています。しかし、Reactでは、この状態もReactの<strong>State</strong>で一元管理するのがベストプラクティスです。このパターンのことを<strong>制御コンポーネント (Controlled Component)</strong> と呼びます。</p>
<p><strong>制御コンポーネントの実装ステップ:</strong><br />
1.  入力値を保持するためのStateを<code>useState</code>で宣言する。<br />
2.  <code>input</code>要素の<code>value</code>属性に、そのState変数をバインドする。<br />
3.  <code>input</code>要素の<code>onChange</code>イベントを捕捉し、イベントハンドラを定義する。<br />
4.  イベントハンドラ内で、<code>event.target.value</code>を使って入力値を取得し、セッター関数でStateを更新する。</p>
<p><strong>例：名前入力フォーム</strong></p>
<pre class="codehilite"><code class="language-tsx">// NameForm.tsx
import { useState } from &quot;react&quot;;

function NameForm() {
  // 1. 入力値を保持するState
  const [name, setName] = useState(&quot;&quot;);

  // 3. onChangeイベントハンドラ
  const handleChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    // 4. 入力値でStateを更新
    setName(event.target.value);
  };

  return (
    &lt;div&gt;
      &lt;input 
        type=&quot;text&quot; 
        // 2. value属性にStateをバインド
        value={name} 
        onChange={handleChange} 
      /&gt;
      &lt;p&gt;あなたの名前は: {name}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<ul>
<li><strong><code>React.ChangeEvent&lt;HTMLInputElement&gt;</code></strong>: <code>onChange</code>イベントオブジェクトの型です。ジェネリクスで、イベントの発生源が<code>HTMLInputElement</code>であることを明記しています。</li>
</ul>
<p><strong>なぜ制御コンポーネントを使うのか？</strong><br />
-   <strong>単一の信頼できる情報源 (Single Source of Truth):</strong> 入力値が常にReactのStateに保持されるため、データがどこにあるかが明確になります。<br />
-   <strong>動的な操作:</strong> Stateを更新するだけで、入力値をプログラム側から変更したり（例: クリアボタン）、バリデーションをかけたりすることが容易になります。</p>
<hr />
<h3 id="state_1">🔒 安全なState更新：更新関数を使う</h3>
<p>前のセクションで、「Stateの更新は非同期である」と学びました。これにより、前のStateの値に依存する更新処理が、意図通りに動かないことがあります。</p>
<p><strong>❌ 問題が起こる例：カウンターを一度に2回インクリメントしたい</strong></p>
<pre class="codehilite"><code class="language-tsx">const handleDoubleIncrement = () =&gt; {
  setCount(count + 1); // この時点ではまだcountは古い値
  setCount(count + 1); // ここでも同じ古い値を使ってしまう
};
// 結果：1しか増えない
</code></pre>

<p>この問題を解決するには、セッター関数に新しい値を直接渡すのではなく、<strong>「現在のStateを受け取り、新しいStateを返す関数」（更新関数）</strong>を渡します。</p>
<p><strong>⭕ 正しい方法：更新関数を渡す</strong></p>
<pre class="codehilite"><code class="language-tsx">const handleDoubleIncrement = () =&gt; {
  // (prevCount) =&gt; prevCount + 1 という関数を渡す
  setCount((prevCount) =&gt; prevCount + 1);
  setCount((prevCount) =&gt; prevCount + 1);
};
// 結果：期待通り2増える
</code></pre>

<ul>
<li><code>prevCount</code>という引数には、Reactが保証する<strong>最新のStateの値</strong>が渡されます。</li>
<li>Reactはこれらの更新関数をキューに入れ、順番に実行するため、前の更新結果が次の更新に正しく反映されます。</li>
</ul>
<p><strong>ルール:</strong> <strong>前のStateの値に基づいて次のStateを計算する場合は、必ず更新関数形式を使いましょう。</strong></p>
<hr />
<p>✨ <strong>まとめ</strong></p>
<ul>
<li>JSXのイベントハンドリングは、<code>onClick={handleClick}</code>のように、<code>camelCase</code>の属性に関数を渡すことで行う。</li>
<li>フォーム要素の値をReactのStateで管理する手法を<strong>制御コンポーネント</strong>と呼び、React開発の基本パターンである。</li>
<li>制御コンポーネントは、<code>value</code>をStateにバインドし、<code>onChange</code>でStateを更新することで実装する。</li>
<li>Stateの更新は非同期であるため、前のStateの値に依存する更新処理を行う場合は、<code>setState(prev =&gt; prev + 1)</code>のように<strong>更新関数</strong>を渡すのが安全である。</li>
</ul>
<p>📝 <strong>学習のポイント</strong></p>
<ul>
<li>[ ] <code>onClick={handleClick()}</code>と<code>onClick={handleClick}</code>の違いを、もう一度自分の言葉で説明してください。</li>
<li>[ ] 制御コンポーネントではない、昔ながらのフォーム（非制御コンポーネント）では、入力された値を取得するためにどのような方法が使われていたか調べてみましょう。（ヒント: <code>ref</code>）</li>
<li>[ ] チェックボックス（<code>&lt;input type="checkbox"&gt;</code>）を制御コンポーネントにする場合、<code>value</code>属性の代わりにどの属性をStateにバインドし、<code>event.target</code>からどのプロパティを取得する必要があるでしょうか？</li>
</ul>
</div>
<div class="section-nav">
<a href="tutorial07_React入門_chapter03_Stateによる状態管理_7-3-1: StateとuseStateフック.html" class="prev">StateとuseStateフック</a>
<a href="tutorial07_React入門_chapter03_Stateによる状態管理_7-3-3: オブジェクトと配列のState管理.html" class="next">オブジェクトと配列のState管理</a>
</div>

                </div>
            </div>
        </div>
        <footer>
            &copy; 2025 pro-contents
        </footer>
    </div>
</body>
</html>
