<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>useEffectフックの使い方 | pro-contents</title>
    <meta name="description" content="Pro生用プログラミング教材コンテンツ">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div id="outer">
        <header>
            <h1><a href="index.html">pro-contents</a></h1>
            <p class="description">Pro生用プログラミング教材コンテンツ</p>
        </header>
        <div id="container">
            <aside>
                <div id="side-inner">
                    <div class="side-title">チュートリアル一覧</div>
<div class="side"><ul>
<li><a href="tutorial01_開発環境とWebの基礎固め.html">Tutorial 1: 開発環境とWebの基礎固め</a></li>
<li><a href="tutorial02_HTML_CSS基礎.html">Tutorial 2: HTML/CSS基礎</a></li>
<li><a href="tutorial03_Tailwind_CSS徹底習得.html">Tutorial 3: Tailwind CSS徹底習得</a></li>
<li><a href="tutorial04_JavaScript_基礎とDOM操作.html">Tutorial 4: JavaScript基礎とDOM操作</a></li>
<li><a href="tutorial05_JavaScript_応用と非同期処理.html">Tutorial 5: JavaScript応用と非同期処理</a></li>
<li><a href="tutorial06_TypeScript入門.html">Tutorial 6: TypeScript入門</a></li>
<li><a href="tutorial07_React入門.html">Tutorial 7: React入門</a></li>
<li><a href="tutorial08_React応用.html" class="current">Tutorial 8: React応用</a></li>
<li><a href="tutorial09_Next.js.html">Tutorial 9: Next.js</a></li>
<li><a href="tutorial10_Laravel_x_Next.js.html">Tutorial 10: Laravel × Next.js</a></li>
<li><a href="tutorial11_テスト.html">Tutorial 11: テスト</a></li>
<li><a href="tutorial12_column.html">上級コラム: Webレンダリングの深層理解</a></li>
</ul></div>

                </div>
            </aside>
            <div id="content">
                <div class="inner">
                    <div class="breadcrumb"><a href="../index.html">ホーム</a><span>></span><a href="index.html">Laravelエンジニアのためのフロントエンド学習ロードマップ</a><span>></span><a href="tutorial08_React応用.html">Tutorial 8: React応用</a><span>></span><a href="tutorial08_React応用_chapter01_useEffectによる副作用の管理.html">Chapter 1: useEffectによる副作用の管理</a><span>></span>useEffectフックの使い方</div>
                    <div class="section-content">
<h1 id="8-1-2-useeffect">8-1-2: useEffectの基本構文</h1>
<h2 id="chapter-1-useeffect">Chapter 1: <code>useEffect</code>による副作用の管理</h2>
<h3 id="section-2-useeffect">Section 2: <code>useEffect</code>の基本構文</h3>
<p>🎯 <strong>このセクションで学ぶこと</strong></p>
<ul>
<li><code>useEffect</code>フックの基本的な構文を理解する。</li>
<li>副作用を実行するタイミングを制御するための<strong>依存配列 (Dependency Array)</strong> の役割を理解する。</li>
<li>依存配列の3つの主要なパターン（指定しない、空配列、値を含む配列）の違いを説明できるようになる。</li>
</ul>
<hr />
<h3 id="_1">イントロダクション：副作用をいつ実行するか？</h3>
<p><code>useEffect</code>は、副作用をレンダリングから分離するためのフックですが、その真価は「<strong>副作用を実行するタイミングを細かく制御できる</strong>」点にあります。</p>
<ul>
<li>コンポーネントが最初に表示された<strong>ときだけ</strong>実行したい（例: APIから初期データを取得）</li>
<li>特定のStateやPropsが変更された<strong>ときだけ</strong>実行したい（例: 検索クエリが変わったらAPIを再検索）</li>
<li>コンポーネントが再レンダリングされる<strong>たびに</strong>実行したい（あまり使わない）</li>
</ul>
<p>このタイミングの制御を担うのが、<code>useEffect</code>の第二引数である<strong>依存配列 (Dependency Array)</strong> です。</p>
<hr />
<h3 id="useeffect">⚙️ <code>useEffect</code>の基本構文</h3>
<p><code>useEffect</code>は、第一引数に<strong>副作用関数</strong>、第二引数に<strong>依存配列</strong>を取ります。</p>
<pre class="codehilite"><code class="language-tsx">import { useEffect } from 'react';

useEffect(
  // 1. 副作用関数：ここに実行したい副作用処理を書く
  () =&gt; {
    // 例：API通信、DOM操作、タイマー設定など
    console.log(&quot;副作用が実行されました&quot;);
  },
  // 2. 依存配列：副作用関数が「何に依存しているか」をReactに伝える
  [dependency1, dependency2, ...]
);
</code></pre>

<p><strong>動作の基本ルール:</strong><br />
Reactは、コンポーネントのレンダリングが完了した後、<strong>依存配列の中の値が前回のレンダリング時と変更されているか</strong>をチェックします。もし変更があれば、第一引数の副作用関数を実行します。</p>
<hr />
<h3 id="3">🚀 依存配列の3つのパターン</h3>
<p>依存配列の指定方法によって、副作用の実行タイミングは大きく3つのパターンに分かれます。これは<code>useEffect</code>を使いこなす上で最も重要な知識です。</p>
<h4 id="1">パターン1：依存配列を省略する</h4>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  console.log(&quot;毎回のレンダリング後に実行&quot;);
}); // 依存配列を省略
</code></pre>

<ul>
<li><strong>実行タイミング:</strong> コンポーネントが<strong>再レンダリングされるたびに</strong>、副作用関数が実行されます。</li>
<li><strong>主な用途:</strong> このパターンは、意図しない無限ループ（副作用内でStateを更新し、それが再レンダリングを引き起こし、また副作用が…）を引き起こしやすいため、<strong>ほとんど使いません</strong>。使う場面は非常に限定的です。</li>
</ul>
<h4 id="2">パターン2：空の依存配列 <code>[]</code> を指定する</h4>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  console.log(&quot;初回レンダリング後に一度だけ実行&quot;);
}, []); // 空の配列
</code></pre>

<ul>
<li><strong>実行タイミング:</strong> コンポーネントが最初に画面にマウント（表示）された後、<strong>一度だけ</strong>副作用関数が実行されます。</li>
<li><strong>主な用途:</strong> これが最もよく使われるパターンの一つです。<ul>
<li>APIから初期データを取得する</li>
<li><code>window</code>にイベントリスナーを設定する</li>
<li>タイマーを開始する</li>
</ul>
</li>
</ul>
<h4 id="3-dep1-dep2">パターン3：依存配列に値 <code>[dep1, dep2]</code> を指定する</h4>
<pre class="codehilite"><code class="language-tsx">const [count, setCount] = useState(0);
const [name, setName] = useState(&quot;Taro&quot;);

useEffect(() =&gt; {
  console.log(`countが変更されました: ${count}`);
}, [count]); // countに依存

useEffect(() =&gt; {
  console.log(&quot;countかnameが変更されました&quot;);
}, [count, name]); // countとnameに依存
</code></pre>

<ul>
<li><strong>実行タイミング:</strong><ol>
<li>初回レンダリング後に一度実行される。</li>
<li>その後、依存配列に含まれる<strong>いずれかの値が</strong>前回のレンダリング時と変更された場合にのみ、再レンダリング後に副作用関数が実行される。</li>
</ol>
</li>
<li><strong>主な用途:</strong><ul>
<li>特定のPropsやStateの変更をトリガーとして、副作用を実行したい場合。</li>
<li>ユーザーIDが変わったら、新しいユーザーの情報をAPIで取得する。</li>
<li>検索クエリ（State）が変わったら、検索APIを叩き直す。</li>
<li>Propsで渡された<code>isOpen</code>が<code>true</code>に変わったら、モーダルウィンドウを表示するアニメーションを開始する。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="_2">🔒 依存配列のルール</h3>
<p><strong>ルール:</strong> <strong>副作用関数の中で使っている全てのリアクティブな値（Props, State, およびそれらから計算される変数）は、必ず依存配列に含めなければなりません。</strong></p>
<p><strong>❌ やってはいけないこと（依存配列の嘘）:</strong></p>
<pre class="codehilite"><code class="language-tsx">function Counter({ step }) {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    // 副作用関数の中で`step`を使っているのに…
    const intervalId = setInterval(() =&gt; {
      setCount(c =&gt; c + step);
    }, 1000);
    return () =&gt; clearInterval(intervalId);
  }, []); // …依存配列に`step`が含まれていない！
}
</code></pre>

<p>このコードでは、<code>step</code>というPropsが変更されても、<code>useEffect</code>は再実行されません。そのため、タイマーは古い<code>step</code>の値を参照し続け、意図しない挙動になります。</p>
<p><strong>⭕ 正しい方法:</strong></p>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  // ...
}, [step]); // 正しく`step`を依存配列に含める
</code></pre>

<p>幸い、ESLintの<code>react-hooks/exhaustive-deps</code>というルールがデフォルトで有効になっており、依存配列に漏れがあると警告を出してくれます。この警告は<strong>絶対に無視せず</strong>、指示に従って修正してください。</p>
<hr />
<p>✨ <strong>まとめ</strong></p>
<ul>
<li><code>useEffect</code>の第二引数、<strong>依存配列</strong>は、副作用を実行するタイミングを制御する。</li>
<li><strong>依存配列を省略</strong>: 毎回のレンダリング後（非推奨）。</li>
<li><strong>空の依存配列 <code>[]</code></strong>: 初回レンダリング後に一度だけ。</li>
<li><strong>依存配列に値 <code>[dep]</code></strong>: 初回と、<code>dep</code>が変更された後のレンダリング後。</li>
<li><strong>ルール</strong>: 副作用関数内で使っているPropsやStateは、<strong>すべて</strong>依存配列に含める必要がある。</li>
</ul>
<p>📝 <strong>学習のポイント</strong></p>
<ul>
<li>[ ] ユーザーのプロフィールを表示するコンポーネントを考えます。<code>userId</code>というPropsを受け取り、そのIDを使ってAPIからユーザー情報を取得する場合、<code>useEffect</code>の依存配列はどうあるべきですか？</li>
<li>[ ] 画面の横幅を検知してStateに保存するコンポーネントを考えます。<code>window</code>の<code>resize</code>イベントを監視する必要があります。イベントリスナーの登録と解除は、それぞれ<code>useEffect</code>のどの部分で、どの依存配列パターンを使って行うべきでしょうか？</li>
<li>[ ] ESLintの<code>exhaustive-deps</code>ルールは、なぜこれほどまでに重要なのでしょうか？ もしこのルールがなかったら、どのようなバグが生まれやすくなるか想像してみましょう。</li>
</ul>
</div>
<div class="section-nav">
<a href="tutorial08_React応用_chapter01_useEffectによる副作用の管理_8-1-1: このチュートリアルで学ぶこと.html" class="prev">このチュートリアルで学ぶこと</a>
<a href="tutorial08_React応用_chapter01_useEffectによる副作用の管理_8-1-3: クリーンアップ関数.html" class="next">クリーンアップ関数</a>
</div>

                </div>
            </div>
        </div>
        <footer>
            &copy; 2025 pro-contents
        </footer>
    </div>
</body>
</html>
