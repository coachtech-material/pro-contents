<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Propsの基本 | Laravelエンジニアのためのフロントエンド学習ロードマップ</title>
    <meta name="description" content="PHP/Laravelエンジニアがフロントエンド開発を習得するための教材">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="outer">
        <header>
            <h1><a href="index.html">Laravelエンジニアのためのフロントエンド学習ロードマップ</a></h1>
            <p class="description">PHP/Laravelエンジニアがフロントエンド開発を習得するための教材</p>
        </header>
        <div id="container">
            <aside>
                <div id="side-inner">
                    <div class="side-title">チュートリアル一覧</div>
<div class="side"><ul>
<li><a href="tutorial01_開発環境とWebの基礎固め.html">Tutorial 1: 開発環境とWebの基礎固め</a></li>
<li><a href="tutorial02_HTML_CSS基礎.html">Tutorial 2: HTML/CSS基礎</a></li>
<li><a href="tutorial03_Tailwind_CSS徹底習得.html">Tutorial 3: Tailwind CSS徹底習得</a></li>
<li><a href="tutorial04_JavaScript_基礎とDOM操作.html">Tutorial 4: JavaScript基礎とDOM操作</a></li>
<li><a href="tutorial05_JavaScript_応用と非同期処理.html">Tutorial 5: JavaScript応用と非同期処理</a></li>
<li><a href="tutorial06_TypeScript入門.html">Tutorial 6: TypeScript入門</a></li>
<li><a href="tutorial07_React入門.html" class="current">Tutorial 7: React入門</a></li>
<li><a href="tutorial08_React応用.html">Tutorial 8: React応用</a></li>
<li><a href="tutorial09_Next.js.html">Tutorial 9: Next.js</a></li>
<li><a href="tutorial10_Laravel_x_Next.js.html">Tutorial 10: Laravel × Next.js</a></li>
<li><a href="tutorial11_テスト.html">Tutorial 11: テスト</a></li>
<li><a href="tutorial12_column.html">上級コラム: Webレンダリングの深層理解</a></li>
</ul></div>

                </div>
            </aside>
            <div id="content">
                <div class="inner">
                    <div class="breadcrumb"><a href="index.html">ホーム</a><span>></span><a href="tutorial07_React入門.html">Tutorial 7: React入門</a><span>></span><a href="tutorial07_React入門_chapter02_Propsによるデータ受け渡し.html">Chapter 2: Propsによるデータ受け渡し</a><span>></span>Propsの基本</div>
                    <div class="section-content">
<h1 id="7-2-1-props">7-2-1: Propsの基本</h1>
<h2 id="chapter-2-props">Chapter 2: Propsによるデータ受け渡し</h2>
<h3 id="section-1-props">Section 1: Propsの基本と型定義</h3>
<p>🎯 <strong>このセクションで学ぶこと</strong></p>
<ul>
<li><strong>Props</strong> を使って、親コンポーネントから子コンポーネントへデータを渡す方法を習得する。</li>
<li>TypeScriptを使い、コンポーネントが受け取るPropsに<strong>型を定義</strong>する方法を習得する。</li>
<li>Propsが<strong>読み取り専用</strong>であるという重要なルールを理解する。</li>
</ul>
<hr />
<h3 id="_1">イントロダクション：コンポーネントをカスタマイズ可能にする</h3>
<p>前のChapterで、コンポーネントを再利用する方法を学びました。しかし、<code>UserProfile</code>コンポーネントを何度再利用しても、表示されるのはいつも「山田 太郎」さんでした。これでは再利用性が高いとは言えません。</p>
<p>コンポーネントを真に再利用可能にするには、呼び出し元（親コンポーネント）から、表示したいデータ（名前や趣味など）を動的に渡せるようにする必要があります。この「親から子へのデータの受け渡し」を実現する仕組みが <strong>Props</strong> (プロパティ) です。</p>
<p>Propsは、<strong>関数における引数</strong>のようなものだと考えることができます。コンポーネントに引数（Props）を渡すことで、その振る舞いや表示内容をカスタマイズできるのです。</p>
<hr />
<h3 id="props">⚙️ Propsを渡す・受け取る</h3>
<p>Propsの受け渡しは、2つのステップで行われます。</p>
<ol>
<li><strong>親コンポーネント:</strong> 子コンポーネントを呼び出す際に、HTMLの属性のような構文でデータを渡す。</li>
<li><strong>子コンポーネント:</strong> 関数の引数として、渡されたデータがひとまとめになったオブジェクトを受け取る。</li>
</ol>
<p><strong>例：<code>UserProfile</code>コンポーネントに<code>name</code>と<code>hobby</code>を渡す</strong></p>
<p><strong>1. 親コンポーネント (<code>App.tsx</code>)</strong></p>
<pre class="codehilite"><code class="language-tsx">// App.tsx
import UserProfile from &quot;./components/UserProfile&quot;;

function App() {
  return (
    &lt;&gt;
      {/* 属性のような構文でPropsを渡す */}
      &lt;UserProfile name=&quot;山田 太郎&quot; hobby=&quot;プログラミング&quot; /&gt;
      &lt;UserProfile name=&quot;鈴木 花子&quot; hobby=&quot;読書&quot; /&gt;
    &lt;/&gt;
  );
}
</code></pre>

<ul>
<li><code>&lt;UserProfile ... /&gt;</code> の中で、<code>name="..."</code> や <code>hobby="..."</code> のように、属性を渡すのと同じ要領でPropsを指定します。</li>
</ul>
<p><strong>2. 子コンポーネント (<code>UserProfile.tsx</code>)</strong></p>
<pre class="codehilite"><code class="language-tsx">// UserProfile.tsx

// 関数の第一引数としてpropsオブジェクトを受け取る
function UserProfile(props) {
  return (
    &lt;div className=&quot;user-profile&quot;&gt;
      {/* propsオブジェクトのプロパティとしてデータにアクセス */}
      &lt;p&gt;名前: {props.name}&lt;/p&gt;
      &lt;p&gt;趣味: {props.hobby}&lt;/p&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<ul>
<li>子コンポーネントは、その第一引数に、親から渡されたすべてのデータが格納された<strong><code>props</code>オブジェクト</strong>を受け取ります。</li>
<li><code>props.name</code>や<code>props.hobby</code>のように、ドット記法で各データにアクセスできます。</li>
</ul>
<hr />
<h3 id="typescriptprops">🚀 TypeScriptによるPropsの型定義</h3>
<p>上記のコードは動作しますが、TypeScriptの観点からは不完全です。<code>props</code>オブジェクトがどのようなプロパティを持つべきか、型が定義されていないためです。</p>
<p>コンポーネントが受け取るPropsの型は、<code>type</code>エイリアスまたは<code>interface</code>を使って定義するのが一般的です。</p>
<pre class="codehilite"><code class="language-tsx">// UserProfile.tsx

// 1. Propsの型を定義する
type UserProfileProps = {
  name: string;
  hobby: string;
};

// 2. 引数に型注釈を付け、分割代入で受け取る
function UserProfile({ name, hobby }: UserProfileProps) {
  return (
    &lt;div className=&quot;user-profile&quot;&gt;
      &lt;p&gt;名前: {name}&lt;/p&gt;
      &lt;p&gt;趣味: {hobby}&lt;/p&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
  );
}

export default UserProfile;
</code></pre>

<p><strong>解説:</strong><br />
1.  <code>type UserProfileProps = { ... }</code> で、<code>UserProfile</code>コンポーネントが<code>string</code>型の<code>name</code>と<code>hobby</code>という2つのPropsを受け取ることを定義します。コンポーネント名の後ろに<code>Props</code>を付けるのが一般的な命名規則です。<br />
2.  <code>function UserProfile({ name, hobby }: UserProfileProps)</code> の部分がポイントです。<br />
    -   <code>{ name, hobby }</code>: これはJavaScriptの<strong>分割代入 (Destructuring assignment)</strong> という機能です。<code>props.name</code>や<code>props.hobby</code>と書く代わりに、<code>props</code>オブジェクトから<code>name</code>と<code>hobby</code>プロパティを直接取り出して、同名の変数として使えるようにします。コードがスッキリして読みやすくなるため、React開発では頻繁に使われます。<br />
    -   <code>: UserProfileProps</code>: 分割代入で受け取るオブジェクトが、先ほど定義した<code>UserProfileProps</code>型に準拠していることをTypeScriptに伝えます。</p>
<p>このように型を定義することで、<code>App.tsx</code>側でPropsを渡し忘れたり、間違った型のデータを渡そうとしたりすると、コンパイルエラーとして即座に検知できるようになります。</p>
<p><strong>❌ 間違った呼び出しの例:</strong></p>
<pre class="codehilite"><code class="language-tsx">// App.tsx

// コンパイルエラー: プロパティ 'hobby' がありません。
&lt;UserProfile name=&quot;佐藤 健&quot; /&gt;

// コンパイルエラー: 型 'number' を型 'string' に割り当てることはできません。
&lt;UserProfile name=&quot;高橋 恵子&quot; hobby={30} /&gt;
</code></pre>

<hr />
<h3 id="props_1">🔒 Propsは読み取り専用</h3>
<p>Propsに関して、一つだけ非常に重要なルールがあります。それは、<strong>「コンポーネントは、受け取った自身のPropsを決して変更してはならない」</strong>というルールです。</p>
<p>Propsは親から子への一方通行のデータです。子コンポーネントが受け取ったPropsを勝手に書き換えてしまうと、データの流れが混乱し、アプリケーションの挙動が予測不能になってしまいます。</p>
<p><strong>❌ やってはいけないこと:</strong></p>
<pre class="codehilite"><code class="language-tsx">function UserProfile({ name, hobby }: UserProfileProps) {
  // エラー！ Propsは読み取り専用です。
  name = &quot;別の名前&quot;; 

  return (...);
}
</code></pre>

<p>Reactでは、このような思想を「純粋関数」という言葉で説明することがあります。同じPropsが与えられれば、必ず同じJSXを返す、副作用のない関数のようにコンポーネントを扱うべき、ということです。</p>
<p>コンポーネント内で時間経過やユーザーの操作によって変化する値を扱いたい場合は、次のChapterで学ぶ<strong>State</strong>という別の仕組みを使います。</p>
<hr />
<p>✨ <strong>まとめ</strong></p>
<ul>
<li><strong>Props</strong>は、親コンポーネントから子コンポーネントへデータを渡すための仕組みである。</li>
<li>親はHTMLの属性のように<code>&lt;MyComponent propName="value" /&gt;</code>と記述してPropsを渡す。</li>
<li>子は関数の引数として<code>props</code>オブジェクトを受け取る。<strong>分割代入</strong>で受け取るのがモダンな書き方。</li>
<li>TypeScriptでは、<code>type</code>や<code>interface</code>を使ってPropsの型を定義し、コンポーネントの引数に注釈する。</li>
<li>Propsは<strong>読み取り専用</strong>であり、子コンポーネント内で直接変更してはならない。</li>
</ul>
<p>📝 <strong>学習のポイント</strong></p>
<ul>
<li>[ ] Propsは、通常のJavaScript関数における何に似ていますか？</li>
<li>[ ] 分割代入を使うと、コードの可読性がどのように向上しますか？ <code>props.name</code>と書くのと<code>name</code>と書くのでは、どのような違いがありますか？</li>
<li>[ ] なぜPropsは読み取り専用でなければならないのでしょうか？ もし子コンポーネントが自由にPropsを変更できたら、どのような問題が起こりうるか想像してみてください。</li>
</ul>
</div>
<div class="section-nav">
<span></span>
<a href="tutorial07_React入門_chapter02_Propsによるデータ受け渡し_7-2-2: childrenプロップスの使い方.html" class="next">childrenプロップスの使い方</a>
</div>

                </div>
            </div>
        </div>
        <footer>
            &copy; 2025 Laravelエンジニアのためのフロントエンド学習ロードマップ
        </footer>
    </div>
</body>
</html>
