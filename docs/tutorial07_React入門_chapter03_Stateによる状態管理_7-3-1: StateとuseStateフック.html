<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StateとuseStateフック | Laravelエンジニアのためのフロントエンド学習ロードマップ</title>
    <meta name="description" content="PHP/Laravelエンジニアがフロントエンド開発を習得するための教材">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="outer">
        <header>
            <h1><a href="index.html">Laravelエンジニアのためのフロントエンド学習ロードマップ</a></h1>
            <p class="description">PHP/Laravelエンジニアがフロントエンド開発を習得するための教材</p>
        </header>
        <div id="container">
            <aside>
                <div id="side-inner">
                    <div class="side-title">チュートリアル一覧</div>
<div class="side"><ul>
<li><a href="tutorial01_開発環境とWebの基礎固め.html">Tutorial 1: 開発環境とWebの基礎固め</a></li>
<li><a href="tutorial02_HTML_CSS基礎.html">Tutorial 2: HTML/CSS基礎</a></li>
<li><a href="tutorial03_Tailwind_CSS徹底習得.html">Tutorial 3: Tailwind CSS徹底習得</a></li>
<li><a href="tutorial04_JavaScript_基礎とDOM操作.html">Tutorial 4: JavaScript基礎とDOM操作</a></li>
<li><a href="tutorial05_JavaScript_応用と非同期処理.html">Tutorial 5: JavaScript応用と非同期処理</a></li>
<li><a href="tutorial06_TypeScript入門.html">Tutorial 6: TypeScript入門</a></li>
<li><a href="tutorial07_React入門.html" class="current">Tutorial 7: React入門</a></li>
<li><a href="tutorial08_React応用.html">Tutorial 8: React応用</a></li>
<li><a href="tutorial09_Next.js.html">Tutorial 9: Next.js</a></li>
<li><a href="tutorial10_Laravel_x_Next.js.html">Tutorial 10: Laravel × Next.js</a></li>
<li><a href="tutorial11_テスト.html">Tutorial 11: テスト</a></li>
<li><a href="tutorial12_column.html">上級コラム: Webレンダリングの深層理解</a></li>
</ul></div>

                </div>
            </aside>
            <div id="content">
                <div class="inner">
                    <div class="breadcrumb"><a href="index.html">ホーム</a><span>></span><a href="tutorial07_React入門.html">Tutorial 7: React入門</a><span>></span><a href="tutorial07_React入門_chapter03_Stateによる状態管理.html">Chapter 3: Stateによる状態管理</a><span>></span>StateとuseStateフック</div>
                    <div class="section-content">
<h1 id="7-3-1-stateusestate">7-3-1: StateとuseStateフック</h1>
<h2 id="chapter-3-state">Chapter 3: Stateによる状態管理</h2>
<h3 id="section-1-stateusestate">Section 1: Stateと<code>useState</code>フック</h3>
<p>🎯 <strong>このセクションで学ぶこと</strong></p>
<ul>
<li>コンポーネントが持つ「記憶」である <strong>State</strong> の概念を理解する。</li>
<li>PropsとStateの役割の違い（外部から渡される vs 内部で管理する）を説明できるようになる。</li>
<li>Reactの <strong>フック (Hook)</strong> の概念と、最も基本的なフックである <strong><code>useState</code></strong> の使い方を習得する。</li>
</ul>
<hr />
<h3 id="ui">イントロダクション：インタラクティブなUIへ</h3>
<p>Propsを使うことで、コンポーネントは静的なデータを表示できるようになりました。しかし、Webアプリケーションには、ユーザーの操作によって変化する要素が不可欠です。例えば、</p>
<ul>
<li>クリックすると数が増えるカウンター</li>
<li>入力すると文字が反映されるテキストフィールド</li>
<li>「いいね！」ボタンを押すと色が変わる</li>
</ul>
<p>このような「時間と共に変化するデータ」をコンポーネントに記憶させ、UIに反映させるための仕組みが <strong>State</strong> です。</p>
<p>Propsが「親から渡される、変更不可能な設定値」だとすれば、Stateは「<strong>コンポーネント自身が内部で管理する、変更可能なデータ（記憶）</strong>」と言うことができます。</p>
<hr />
<h3 id="hook">⚙️ フック (Hook) とは？</h3>
<p>Stateを関数コンポーネントで利用するためには、Reactが提供する特別な関数である <strong>フック (Hook)</strong> を使います。</p>
<p>フックは、関数コンポーネントに、Stateの保持やライフサイクル（後述）といったReactの機能を「引っ掛ける (hook into)」ための仕組みです。フックは、必ず<code>use</code>というプレフィックスで始まります（例: <code>useState</code>, <code>useEffect</code>）。</p>
<p>このセクションでは、最も基本的で重要なフックである <strong><code>useState</code></strong> を学びます。</p>
<hr />
<h3 id="usestate">🚀 <code>useState</code> の使い方</h3>
<p><code>useState</code>は、コンポーネントにState（状態）を追加するためのフックです。</p>
<p><code>useState</code>を呼び出すと、<strong>State変数</strong>と、そのStateを更新するための<strong>セッター関数</strong>のペアが、配列として返ってきます。</p>
<p><strong><code>useState</code>の基本構文:</strong></p>
<pre class="codehilite"><code class="language-tsx">import { useState } from 'react';

function MyComponent() {
  // useStateを呼び出し、配列の分割代入で変数とセッター関数を受け取る
  const [stateVariable, setFunction] = useState(initialValue);

  // ...
}
</code></pre>

<ul>
<li><strong><code>initialValue</code></strong>: Stateの初期値。コンポーネントが最初にレンダリングされるときに一度だけ使われます。</li>
<li><strong><code>stateVariable</code></strong>: 現在のStateの値を保持する変数。この変数の値が変更されると、Reactはコンポーネントを再レンダリングします。</li>
<li><strong><code>setFunction</code></strong>: Stateを更新するための関数。<strong>Stateを直接変更することはできず、必ずこのセッター関数を使って更新します。</strong></li>
</ul>
<p><strong>例：シンプルなカウンターコンポーネント</strong></p>
<pre class="codehilite"><code class="language-tsx">// Counter.tsx
import { useState } from 'react';

function Counter() {
  // 1. useStateを呼び出し、countというState変数を宣言
  //    初期値は 0
  const [count, setCount] = useState(0);

  // 2. ボタンがクリックされたときに呼ばれる関数
  const increment = () =&gt; {
    // 3. セッター関数を呼び出して、countの値を更新する
    setCount(count + 1);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;現在のカウント: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;カウントアップ&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p><strong>動作の流れ:</strong><br />
1.  コンポーネントが最初に表示されるとき、<code>useState(0)</code>が呼ばれ、<code>count</code>は<code>0</code>になる。画面には「現在のカウント: 0」と表示される。<br />
2.  ユーザーがボタンをクリックすると、<code>increment</code>関数が実行される。<br />
3.  <code>setCount(count + 1)</code>が呼ばれる。現在の<code>count</code>は<code>0</code>なので、<code>setCount(1)</code>が実行される。<br />
4.  <strong><code>setCount</code>が呼ばれると、Reactは<code>count</code>というStateが変更されたことを検知し、<code>Counter</code>コンポーネントの再レンダリングをスケジュールする。</strong><br />
5.  <code>Counter</code>コンポーネントが再実行（再レンダリング）される。このとき、<code>useState(0)</code>は2回目以降は無視され、<code>count</code>変数は更新された値である<code>1</code>を持つ。<br />
6.  画面には「現在のカウント: 1」と表示される。</p>
<hr />
<h3 id="state">🔒 State更新の重要なルール</h3>
<h4 id="1-state">1. Stateを直接変更しない</h4>
<p>State変数は読み取り専用のように扱ってください。直接代入しても、Reactは変更を検知できず、再レンダリングは発生しません。</p>
<p><strong>❌ やってはいけないこと:</strong></p>
<pre class="codehilite"><code class="language-tsx">const increment = () =&gt; {
  count = count + 1; // ダメ！再レンダリングされない
};
</code></pre>

<p><strong>⭕ 正しい方法:</strong></p>
<pre class="codehilite"><code class="language-tsx">const increment = () =&gt; {
  setCount(count + 1); // 必ずセッター関数を使う
};
</code></pre>

<h4 id="2-state">2. Stateの更新は非同期</h4>
<p>セッター関数（例: <code>setCount</code>）を呼び出しても、State変数が<strong>即座に</strong>更新されるわけではありません。Reactは、パフォーマンスのために複数のState更新をまとめてバッチ処理することがあります。</p>
<pre class="codehilite"><code class="language-tsx">const handleClick = () =&gt; {
  setCount(count + 1); // countの更新をスケジュール
  console.log(count);  // まだ古い値(0)が表示される！

  setCount(count + 1); // これも count + 1 をスケジュール
  console.log(count);  // やはり古い値(0)が表示される！
};
</code></pre>

<p>この場合、最終的に<code>count</code>は<code>1</code>にしかなりません。前のStateの値に基づいて更新を行いたい場合は、<strong>更新関数</strong>をセッターに渡す必要があります。（これは次のセクションで詳しく学びます）</p>
<hr />
<h3 id="state_1">⚙️ 複数のState変数を持つ</h3>
<p>一つのコンポーネントは、複数のState変数を好きなだけ持つことができます。関連性の低いデータは、別々のStateとして管理するのが良い設計です。</p>
<pre class="codehilite"><code class="language-tsx">function UserForm() {
  const [name, setName] = useState('');
  const [age, setAge] = useState(20);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // ...
}
</code></pre>

<hr />
<p>✨ <strong>まとめ</strong></p>
<ul>
<li><strong>State</strong>は、コンポーネントが内部で保持・管理する、時間と共に変化するデータ（記憶）である。</li>
<li><strong>フック (Hook)</strong> は、関数コンポーネントにReactの機能を追加するための特別な関数で、<code>use</code>で始まる。</li>
<li><strong><code>useState</code></strong> フックは、コンポーネントにStateを追加する。<code>[state, setState]</code>のペアを返す。</li>
<li>Stateの更新は、必ず<strong>セッター関数 (<code>setState</code>)</strong> を使って行う。直接代入しても再レンダリングは起こらない。</li>
<li>セッター関数を呼ぶと、Reactはそのコンポーネントの<strong>再レンダリング</strong>をスケジュールする。</li>
<li>Stateの更新は非同期的に行われる。</li>
</ul>
<p>📝 <strong>学習のポイント</strong></p>
<ul>
<li>[ ] PropsとStateの最も大きな違いは何ですか？それぞれの役割を、演劇に例えて説明してみてください。（Props: 脚本、State: 役者の感情など）</li>
<li>[ ] なぜStateを直接変更してはいけないのでしょうか？ Reactが変更を検知できなくなる理由を考えてみましょう。</li>
<li>[ ] <code>useState</code>が返す配列を、<code>const stateArray = useState(0); const count = stateArray[0]; const setCount = stateArray[1];</code> のように分割代入を使わずに書いた場合、コードはどうなりますか？ 分割代入の利便性を再確認しましょう。</li>
</ul>
</div>
<div class="section-nav">
<span></span>
<a href="tutorial07_React入門_chapter03_Stateによる状態管理_7-3-2: Stateの更新とイベントハンドリング.html" class="next">Stateの更新とイベントハンドリング</a>
</div>

                </div>
            </div>
        </div>
        <footer>
            &copy; 2025 Laravelエンジニアのためのフロントエンド学習ロードマップ
        </footer>
    </div>
</body>
</html>
